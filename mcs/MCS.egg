-----------------------------------------------------
-- Grammaires de MC  et MCS                       --
-----------------------------------------------------
--options
option auto = true;
option version = 0.0.1;
option k=2;
--attributes 

-- le fichier source
inh source : MCSSourceFile for PROGRAMME;
-- la machine cible pour la generation de code
inh machine : IMachine for 
         ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX
--         -- decommenter la ligne suivante pour MCS
--       , BASE, DEFS, DEF
--         -- fin extension MCS
         ;
-- ces attributs permettent de recuperer les instructions du code ASM inline       
syn code_asm : STRING for ASM;
-- la TDS courante
inh tds_asm : TDS for ASM;

-- Custom attributes
inh tds : TDS for PROGRAMME, ENTITES, ENTITE, DECL,
                  PARF, PARFS, PARFSX, BLOC,
		  INSTS, INST, STYPE, PTRS,
		  CHAMPS, CHAMP,
		  A, AFFX, R, AX, T, TX, F ;
syn type : TYPE for TYPE, FONCTION, PARF, PARFS, PARFSX, DECL,
                    BLOC, INSTS, INST, E, STYPE, PTRS, CHAMPS,
		    A, AFFX, R, AX, T, TX, F ;
inh typePT : TYPE for PTRS ;
inh typeCHP : TYPE for CHAMPS, CHAMP ;

--terminals
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar virg is  ",";
sugar pt is "\.";
sugar pv is  "\;";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar asm is  "asm";
sugar int is  "int";
sugar char is  "char";
sugar struct is "struct";
sugar typedef is "typedef";
-- decommenter pour MCS
--sugar ref is "ref" ;
--sugar out is "out";
--sugar namespace is "namespace";
--sugar using is "using";
--sugar class is "class";
--sugar public is "public" ;
--sugar private is "private";
--sugar dpts is "\:";
--sugar bool is "bool";
--sugar true is "true";
--sugar false is "false";
--sugar this is "this";
--sugar new is "new" ;
--sugar null2 is "null";
--sugar base is "base" ;
-- 
sugar retour is  "return";
sugar arrow is "\-\>";
sugar null is  "NULL";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
term entier is  "[0-9]+";
term caractere is  "\'[^\']\'";
term chaine is  "\"[^\"]*\"";
term ident is  "[a-z][_0-9A-Za-z]*";
term identc is  "[A-Z][_0-9A-Za-z]*";

-- pour les instructions en assembleur TAM 'inline'
compil ASM;

--production rules
PROGRAMME -> #init ENTITES #gen;
global
   machine : IMachine;
-- transmission de la machine cible  (choisie par l'option -m au lancement) 
#init {
local
do
   machine := PROGRAMME^source.getMachine();
   if machine = null then
     error(NO_MACH, PROGRAMME^source.getMachName());
   else
     ENTITES^machine := machine;
   end
   PROGRAMME^tds := new TDS();
end
}
-- ecrit le code dans un fichier
#gen {
local
do
   machine.writeCode(PROGRAMME^source.getFileName(),"; no code\n");  
end
}
ENTITES -> ;
ENTITES -> ENTITE ENTITES ;
-- definition d'un nom de type (commence par une majuscule)
ENTITE -> typedef TYPE identc pv #record ;
-- Enregistrement du nouveau type dans la table des symboles.
#record {
local
    t : TYPE ;
do
  -- Vérifier qu'aucun type du même nom n'est pas déjà défini localement.
  t := ENTITE^tds.searchType(identc^txt,true);
  if t /= null then
    error(MCS_TAE, identc^txt);
  else
    -- Enregistrement effectif du type.
    ENTITE^tds.putType(identc^txt, TYPE^type);
  end
end
}
-- definition d'une variable globale ou d'une fonction
-- (commence par une minuscule)
ENTITE ->  TYPE ident DECL #record ;
-- Enregistrement de la déclaration dans la table des symboles.
#record {
local
    v : VAR ;
    t : TYPE ;
do
  -- Vérifier qu'aucune fonction/variable du même nom n'est pas déjà définie localement.
  v := ENTITE^tds.searchVar(ident^txt,true);
  if v /= null then
    error(MCS_DAE, ident^txt);
  else
    -- Calcul du type de la variable/fonction.
    if DECL^type = null then
      t := TYPE^type;
    else
      -- TODO calcul du type d'une fonction.
      t := ...
    end
    -- Enregistrement effectif de la déclaration.
    ENTITE^tds.putVar(ident^txt, t);
  end
end
}
-- Variable
DECL -> #type pv ;
#type {
local
do
  DECL^type := null;
end
}
DECL -> #type FONCTION ;
#type {
local
do
  DECL^type := FONCTION^type;
end
}

-- Fonction
FONCTION ->  #tds paro PARFS parf #type BLOC ;
#tds {
local
  tdsFunction : TDS;
do
  tdsFunction := new TDS(FONCTION^tds);
  -- L'évaluation de PARFS va compléter la TDS de la fonction.
  PARFS^tds := tdsFunction;
  BLOC^tds := tdsFunction;
end
}
#type {
local
do
  FONCTION^type := PARFS^type;
end
}

-- parametres de fonctions
PARFS -> #type ;
-- Évaluation du type d'une liste de paramètres.
#type {
local
do
  PARFSX^type := null;
end
}
PARFS ->  PARF PARFSX #type ;
-- Évaluation du type d'une liste de paramètres.
#type {
local
do
  PARFSX1^type.put(PARF^type);
  PARFSX^type := PARFSX1^type;
end
}
PARFSX ->  #type ;
-- Évaluation du type d'une liste de paramètres.
#type {
local
do
  PARFSX^type := null;
end
}
PARFSX ->  virg PARF PARFSX #type ;
-- Évaluation du type d'une liste de paramètres.
#type {
local
do
  PARFSX1^type.put(PARF^type);
  PARFSX^type := PARFSX1^type;
end
}
PARF ->  TYPE ident #type #record ;
-- Évaluation du type d'un paramètre.
#type {
local
do
  PARF^type := TYPE^type;
end
}
-- Enregistrement du paramètre dans la table des symboles de la fonction.
#record {
local
    v : VAR ;
do
  -- Vérifier qu'aucun paramètre du même nom n'est pas déjà défini localement.
  v := PARF^tds.searchVar(ident^txt,true);
  if v /= null then
    error(MCS_PAE, ident^txt);
  else
    -- Enregistrement effectif du paramètre.
    PARF^tds.putVar(ident^txt, TYPE^type);
  end
end
}

-- les types (de base, noms, struct et pointeurs)
TYPE -> STYPE #type1 PTRS #type2 ;
#type1 {
local
do
  PTRS^typePT := STYPE^type;
end
}
#type2 {
local
do
  TYPE^type := PTRS^type;
end
}

-- type de base
-- des * pour definir un pointeur
PTRS -> #type ;
#type {
local
do
  PTRS^type := PTRS^typePT;
end
}
PTRS -> mult PTRS #type ;
#type {
local
  t : PTR;
  o : PTR;
do
  -- Instanciation d'un type pointeur.
  t := new PTR(PTRS1^type);
  -- Recherche du type pointeur dans la table des types.
  o := PTRS^tds.searchType(t.name());
  -- Propagation du type.
  if o /= null then
    -- L'instance précédemment créée.
    PTRS^type := o;
  else
    -- L'instance nouvellement créée.
    PTRS^type := t;
  end
end
}

-- types de base
STYPE-> void #type ;
#type {
local
do
  STYPE^type := STYPE^tds.searchType(void^txt);
end
}

STYPE-> int #type ;
#type {
local
do
  STYPE^type := STYPE^tds.searchType(int^txt);
end
}

STYPE-> char #type ;
#type {
local
do
  STYPE^type := STYPE^tds.searchType(char^txt);
end
}

-- nom de type (commence par une majuscule)
STYPE -> identc #type ;
#type {
local
  t : TYPE;
do
  t := STYPE^tds.searchType(identc^txt);
  if t = null then
    error(MCS_TUN, identc^txt);
  else
    STYPE^type := t;
  end
end
}

-------------  
-- et struct
-- un nom de champ commence par une minuscule
STYPE -> #type1 struct aco CHAMPS acf #type2 ;
-- Création du type struct initial (vide).
#type1 {
local
do
  CHAMPS^typeCHP := new STRUCT();
end
}
-- Propagation du type struct complété.
#type2 {
local
do
  STYPE^type := CHAMPS^type;
end
}

-- Fin de l'évaluation du type struct, propagation du type.
CHAMPS -> #type ;
#type {
local
do
  CHAMPS^type := CHAMPS^typeCHP;
end
}

-- Évaluation du type struct.
CHAMPS -> #type1 CHAMP CHAMPS #type2 ;
-- Enregistrement de plusieurs champs.
#type1 {
local
do
  CHAMP^typeCHP := CHAMPS^typeCHP;
  CHAMPS1^typeCHP := CHAMPS^typeCHP;
end
}
#type2 {
local
do
  CHAMPS^type := CHAMPS1^type;
end
}

CHAMP -> TYPE ident pv #type ;
-- Enregistrement du type d'un champ.
#type {
local
  v : VAR ;
do
  -- Vérifier qu'aucune fonction/variable du même nom n'est pas déjà définie localement.
  v := CHAMP^typeCHP.searchVar(ident^txt,true);
  if v /= null then
    error(MCS_DAE, ident^txt);
  else
    -- Enregistrement effectif de la déclaration.
    CHAMP^typeCHP.putVar(ident^txt, TYPE^type);
  end
end
}

-- corps de fonction et bloc d'instructions
BLOC ->  aco INSTS acf #type ;
#type {
local
do
  BLOC^type := INSTS^type;
end
}

-- instructions
INSTS -> #type ;
#type {
local
do
  INSTS^type := null;
end
}

INSTS ->  INST INSTS #type ;
-- Le type d'une instruction INST (différent d'une expression E) est soit :
--  - null (effet de bord)
--  - résultat d'un return
#type {
local
do
  -- Le type d'une lite d'instructions INSTS et le type de la première INST
  -- de type non null (ie du premier return de la séquence).
  if INST^type /= null then
    INSTS^type := INST^type;
  else
    INSTS^type := INSTS1^type;
  end
end
}
-- declaration de variable locale avec ou sans init 
INST ->  TYPE ident AFFX pv #type ;
#type {
local
do
  -- Une déclaration locale ou affectation est un effet de bord : pas de type associé.
  INST^type := null;

  -- TODO: Vérification cohérence de type ident/expression affectée.

end
}
-- instruction expression (affectation et appel de procedure)
INST -> E pv #type ;
#type {
local
do
  -- Une expression non récupérée est un effet de bord : pas de type associé.
  INST^type := null;
end
}
-- bloc d'instructions
INST ->  BLOC #type ;
#type {
local
do
  INST^type := BLOC^type;
end
}
-- conditionnelle
INST ->   si paro E parf BLOC SIX #type ;
#type {
local
do
  if E^type /= INST^tds.searchType(int^txt) then
    -- TODO: Compléter le message d'erreur avec du texte représentant l'expression.
    error(MCS_NOT_BOOLEAN);
  else
    if BLOC^type /= null then
      if SIX^type /= null then
	if BLOC^type /= SIX^type then 
	  -- Les deux bloc renvoient des types différents, ce qui ne peut donc pas être compatible avec le type de la fonction.
	  error(MCS_BAD_TYPE);
	else
	  -- Les deux blocs existent et renvoient le même type.
	  INST^type := BLOC^type;
	end
      else
	-- Pas de deuxième bloc ou alors il ne contient que des effets de bord.
	INST^type := BLOC^type;
      end
    else
      -- Le premier bloc ne contient que des effets de bord.
      INST^type := SIX^type;
    end
  end
end
}

SIX -> sinon BLOC #type ;
#type {
local
do
  SIX^type := BLOC^type;
end
}
SIX -> #type ;
#type {
local
do
  SIX^type := null;
end
}
-- retour de fonction
INST ->  retour  E pv #type ;
#type {
local
do
  -- Instruction return : on transfère le type de l'expression renvoyée.
  INST^type := E^type;
end
}

-- les expressions -------------
-----------------------------------------------------------------------
-- E = expression (y compris l'affectation)
-- A = expression figurant dans une affectation
-- R = expression figurant dans une expresion relationnelle
-- T = expression figurant dans une expression additive (TERME)
-- F = expression figurant dans une expression multiplicative (FACTEUR)
-----------------------------------------------------------------------
E ->   A  AFFX #type ;
-- Vérification du type des affectations.
#type {
local
do
  if AFFX^type /= null && AFFX^type /= A^type then
    error(MCS_BAD_TYPE_2);
  end
  E^type := A^type;
end
}
-- affectation
AFFX -> affect  A #type ;
-- Vérification du type des affectations (suite).
#type {
local
do
  AFFX^type := A^type;
end
}
AFFX -> #type ;
-- Vérification du type des affectations (fin).
#type {
local
do
  AFFX^type := null;
end
}

-- relation
A -> R AX #type ;
-- Vérification du type d'une relation.
#type {
local
do
  if AX^type /= null then
    if AX^type /= R^type then
      error(MCS_BAD_TYPE_3);
    else
      -- Condition : type int ou bool selon la version.
      A^type := A^tds.searchType(int^txt);
    end
  else
    A^type := R^type;
  end
end
}
AX -> OPREL R #type ;
-- Vérification du type d'une relation (suite).
#type {
local
do
  AX^type := R^type;
end
}
AX -> #type ;
-- Vérification du type d'une relation (fin).
#type {
local
do
  AX^type := null;
end
}

-- operateurs relationnels
OPREL -> inf ;
OPREL -> sup ;
OPREL -> infeg ;
OPREL -> supeg ;
OPREL -> eg ;
OPREL -> neg ;

R ->  T RX #type ;
-- Vérification du type d'une opération additive.
#type {
local
do
  if RX^type /= null && RX^type /= T^type then
      error(MCS_BAD_TYPE_4);
  else
    R^type := T^type;
  end
end
}
-- additions ...
RX -> OPADD T RX #type ;
-- Vérification du type d'une opération additive (suite).
#type {
local
do
  if RX1^type /= null && RX1^type /= T^type then
      error(MCS_BAD_TYPE_4);
  else
    RX^type := T^type;
  end
end
}
RX -> #type ;
-- Vérification du type d'une opération additive (fin).
#type {
local
do
  RX^type := null;
end
}

-- operateurs additifs
OPADD -> plus ;
OPADD -> moins ;
OPADD -> ou ;

-- multiplication, ...
T -> F TX #type ;
-- Vérification du type d'une opération multiplicative.
#type {
local
do
  if TX^type /= null && TX^type /= F^type then
      error(MCS_BAD_TYPE_5);
  else
    T^type := F^type;
  end
end
}
TX -> OPMUL F TX #type ;
-- Vérification du type d'une opération multiplicative (suite).
#type {
local
do
  if TX1^type /= null && TX1^type /= F^type then
      error(MCS_BAD_TYPE_5);
  else
    TX^type := F^type;
  end
end
}
TX -> #type ;
-- Vérification du type d'une opération multiplicative (fin).
#type {
local
do
  TX^type := null;
end
}

-- operateurs multiplicatifs
OPMUL -> mult ;
OPMUL -> div ;
OPMUL -> mod ;
OPMUL -> et ;

-- expressions de base
-- Constante entiere
F -> entier #type ;
#type {
local
do
  F^type := F^tds.searchType(int^txt);
end
}
-- Constante chaine
F -> chaine #type ;
#type {
local
do
  F^type := new PTR(F^tds.searchType(char^txt));
end
}
-- Constante caractere
F -> caractere #type ;
#type {
local
do
  F^type := F^tds.searchType(char^txt);
end
}

-- expression unaire
F -> OPUN F #type ;
#type {
local
do
  F^type := F1^type;
end
}
-- operateurs unaires
OPUN -> plus ;
OPUN -> moins ;
OPUN -> non;

-- pointeur NULL
F -> null #type ;
#type {
local
do
  -- TODO: Vérifier le bon fonctionnement : type null compatible avec les autres dans la vérification de type ?
  F^type := null;
end
}

-- expression parenthesee
F ->  paro E parf FX ;
F ->  paro TYPE parf  F ;
F -> mult F ;
F -> ident FX ;
FX -> ;
-- acces champ
FX ->   pt  ident FX ;
-- acces champ pointeur
FX ->   arrow  ident FX ;
-- appel de sous-programme
FX ->   paro ES parf FX;
-- arguments appel de sous-programme
ES -> ;
ES -> E ESX  ;
ESX ->  ;
ESX -> virg E ESX ;

------------- inline asm ----------------
-- peut être utile pour implanter des sous-programmes
-- directement en assembleur TAM.
ENTITE ->   asm #tds ASM#gen; 
#tds {
do 
  -- A faire : Remplacer 'null' par la table courante pour que
  -- le code  ASM puisse acceder aux variables de MC ou MCS
  ASM^tds_asm := null; 
end
}
#gen {
do
  -- On recupere le code assembleur 'inline' dans : ASM^code_asm ;
end
}

INST ->  asm   #tds ASM #gen ;
#tds {
do
  -- A remplacer par la table courante pour que
  -- l'assembleur puisse acceder aux variables
  ASM^tds_asm := null; 
end
}

#gen {
do
  -- ASM^code_asm contient le code assembleur inline
  -- dans lequel les noms de variables ont ete remplaces
  -- par leurs adresses.
end
}

----------------- CS extension --------------------
-- Decommenter les regles suivantes pour l'extension CS
-------------------------------------------------
--TYPE -> bool;
---- definit un contenu d'un namespace
--ENTITE -> namespace identc aco ENTITES acf ;
---- donne l acces au contenu du 'namespace'
--ENTITE -> using identc IDC pv ;
--IDC -> ;
--IDC -> pt identc IDC ;
---- definition d'une classe (peut etre en dehors d'un namespace)
--ENTITE -> ACCES class identc HERITAGE aco DEFS acf ;
---- acces 
--ACCES -> public;
--ACCES -> private;
--ACCES -> ;
---- heritage
--HERITAGE -> ;
--HERITAGE -> dpts identc IDC ;
---- membres d'une classe
--DEFS -> ;
--DEFS ->  ACCES DEF DEFS ;
--DEF  ->  TYPE ident DECL ;
---- constructeur
--DEF  ->  identc paro PARFS parf BASE BLOC;
---- appel eventuel au constructeur de la classe parente.
--BASE -> ;
--BASE -> dpts base paro ES parf  ;
---- Mode de passage pour les fonctions et méthodes : rien : D, ref : D/R, out : R
--PARF ->  MODE TYPE ident ;
--MODE -> ref ;
--MODE -> out ; 
--F -> true;
--F -> false;
--F -> this FX;
--F -> base FX;
--F -> null2;
--F -> new identc IDC paro ES parf ;
end
