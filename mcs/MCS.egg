-----------------------------------------------------
-- Grammaires de MC  et MCS                        --
-----------------------------------------------------

--
-- Options
option auto = true;
option version = 0.0.1;
option k=2;

--
-- Attributes

-- Le fichier source
inh source : MCSSourceFile for PROGRAMME;

-- La machine cible pour la generation de code.
-- inh machine : IMachine for
--        ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
--        PARFS, PARF, PARFSX, ES, ESX,
--        E, AFFX, A, AX, R, RX, T, TX, F, FX
--      -- Decommenter la ligne suivante pour MCS
--      , BASE, DEFS, DEF
--      -- Fin extension MCS
--        ;

-- Ces attributs permettent de recuperer les instructions du code ASM inline.
syn code_asm : STRING for ASM;

-- La TDS courante.
inh tds_asm : TDS for ASM;

-- Custom attributes.
inh tds : TDS for
        PROGRAMME, ENTITES, ENTITE, DECL,
        FONCTION, PARF, PARFS, PARFSX, BLOC,
        INSTS, INST, TYPE, STYPE, PTRS,
        CHAMPS, CHAMP,
        E, A, AFFX, R, RX, AX, T, TX, F, FX, SIX,
        ES, ESX,
        IDC, HERITAGE, DEF, DEFS ;
        -- TODO: Verifier qu'IDC...DEFS ont vraiment une bonne raison d'etre la.

syn type : TYPE for
        TYPE,
        BLOC, INSTS, INST, E, STYPE, PTRS,
        A, AFFX, R, AX, T, TX, F, FX, SIX, RX ;

-- Typage d'un enregistrement.
inh typeCHP : STRUCT for CHAMPS, CHAMP;

-- Type a gauche d'une declaration.
inh typeLeft : TYPE for DECL, PTRS, FX;

-- Typage appel de sous-programme.
inh typeF : FTYPE for ES, ESX ;
inh numParam : Integer for ESX;

-- Typage declaration de fonction.
syn varF : FCT for DECL ;
inh fct : FCT for FONCTION, PARFS, PARFSX, PARF,
        BLOC, INSTS, INST, SIX ;

-- Le generateur de code.
inh gen : GeneratorItf for
        PROGRAMME, ENTITES, ENTITE, DECL,
        FONCTION, PARF, PARFS, PARFSX, BLOC,
        INSTS, INST, TYPE, STYPE, PTRS,
        CHAMPS, CHAMP,
        E, A, AFFX, R, RX, AX, T, TX, F, FX, SIX,
        OPREL, OPADD, OPMUL, OPUN,
        ES, ESX,
        DEF,DEFS;

-- Le code genere.
syn code : String for
         ENTITES, ENTITE, DECL, FONCTION,
         BLOC, INSTS, INST, AFFX, E, SIX,
         AX, OPREL, RX, OPADD, TX, OPMUL, OPUN,
         ES, ESX ;

-- Nom de l'ident a gauche d'une declaration.
inh name : String for DECL, FX;

-- Code generant une adresse.
syn leftCode : String for A, R, T, F, FX ;
-- Code generant une valeur.
syn rightCode : String for A, R, T, F, FX ;

-- Permet de savoir si on arrive à la fin d'une expression.
syn endl : Boolean for FX;

-- Permet de savoir si les parametres d'une operation doivent etre au prealable convertis en booleens.
syn toBool : Boolean for OPADD, OPMUL ;

-- Permet de retourner une valeur pour savoir si il s'agit d'un scope publique.
syn isPub : Boolean for ACCES ;

-- Déclaration de la classe
inh classHere : CLASS for DEFS, DEF ;

-- Terminaux
space separateur is    "[\r\n\t ]+";
space comm is    "\/\/[^\n]*\n";
sugar paro is    "\(";
sugar parf is    "\)";
sugar aco is    "\{";
sugar acf is    "\}";
sugar virg is    ",";
sugar pt is "\.";
sugar pv is    "\;";
sugar affect is    "=";
sugar si is    "if";
sugar sinon is    "else";
sugar void is    "void";
sugar asm is    "asm";
sugar int is    "int";
sugar char is    "char";
sugar struct is "struct";
sugar typedef is "typedef";

-- Decommenter pour MCS
sugar ref is "ref" ;
sugar out is "out";
sugar namespace is "namespace";
sugar using is "using";
sugar class is "class";
sugar public is "public" ;
sugar private is "private";
sugar dpts is "\:";
sugar bool is "bool";
sugar true is "true";
sugar false is "false";
sugar this is "this";
sugar new is "new" ;
sugar null2 is "null";
sugar base is "base" ;

sugar retour is    "return";
sugar arrow is "\-\>";
sugar null is    "NULL";
sugar inf is    "\<";
sugar infeg is    "\<=";
sugar sup is    "\>";
sugar supeg is    "\>=";
sugar eg is    "==";
sugar neg is    "\!=";
sugar plus is    "\+";
sugar moins is    "\-";
sugar ou is    "\|\|";
sugar mult is    "\*";
sugar div is    "\/";
sugar mod is    "\%" ;
sugar et is    "\&\&";
sugar non is    "\!";
term entier is    "[0-9]+";
term caractere is    "\'[^\']\'";
term chaine is    "\"[^\"]*\"";
term ident is    "[a-z][_0-9A-Za-z]*";
term identc is    "[A-Z][_0-9A-Za-z]*";

-- Pour les instructions en assembleur TAM 'inline'.
compil ASM;

--
--
-- Regle de production, point d'entree.
PROGRAMME -> #init ENTITES #gen;
global
    -- Transmission de la machine cible (choisie par l'option -m au lancement)
    --machine : IMachine;
    gen: GeneratorItf;

-- Initialise le compilateur.
#init { -- {{{
local
    string : TYPE;
    tds : TDS;
do
--    machine := PROGRAMME^source.getMachine();
    gen := new TamGenerator(PROGRAMME^source.getFileName()); -- On reviendra sur le choix de la machine plus tard.
    if gen = null then
        error(NO_MACH, PROGRAMME^source.getMachName());
    else
        ENTITES^gen := gen;
    end

    tds := new TDS();
    -- Ajouter a la TDS les types natifs.
    tds.putType("void", new TYPE("void", 0));
    tds.putType("int", new TYPE("int", 1));
    tds.putType("char", new TYPE("char", 1));
    tds.putType("bool", new TYPE("bool", 1));
    string := new PTR(tds.searchType("char", true));
    tds.putType(string.name(), string);

    ENTITES^tds := tds;
end
} -- }}}

-- Ecrit le code dans un fichier.
#gen { -- {{{
local
    h : HelperGeneralInterface;
do
    h := gen.getGeneralHelper();
    gen.generateFile(h.generateComment(gen.getFileName()) + ENTITES^code + h.generateEnd());
end
} -- }}}

--
--
-- -- Entites
--
--

ENTITES -> #code;

-- Fin de liste d'instructions, plus de code a generer.
#code { -- {{{
local
do
    ENTITES^code := "";
end
} -- }}}

ENTITES -> ENTITE ENTITES #code;

-- Generetion du code d'une sequence d'entites.
#code { -- {{{
local
do
    ENTITES^code := ENTITE^code + ENTITES1^code;
end
} -- }}}

--
--
-- Definition d'un nom de type (commence par une majuscule).
ENTITE -> typedef TYPE identc pv #record #code;

-- Enregistrement du nouveau type dans la table des symboles.
#record { -- {{{
local
    t : TYPE ;
do
    -- Verifier qu'aucun type du meme nom n'est pas deja defini localement.
    t := ENTITE^tds.searchType(identc^txt, false);
    if t /= null then
        error(MCS_TAE, identc^txt);
    else
        -- Enregistrement effectif du type.
        if TYPE^type = null then
            error(MCS_TYPE_NULL, identc^txt);
        else
            ENTITE^tds.putType(identc^txt, TYPE^type);
        end
    end
end
} -- }}}

#code { -- {{{
local
do
    ENTITE^code := "; typedef de "+identc^txt+"\n";
end
} -- }}}

--
--
-- Definition d'une variable globale ou d'une fonction.
-- (Commence par une minuscule)
ENTITE -> TYPE ident #prerecord DECL #record #code ;

-- Verification de la non existence de l'ident dans la tds locale.
#prerecord { -- {{{
local
    v : VAR ;
do
    -- Verifier qu'aucune fonction/variable du meme nom n'est pas deja definie
    -- localement.
    v := ENTITE^tds.searchVar(ident^txt, false);
    if v /= null then
        error(MCS_DAE, ident^txt);
    else
        -- Propagation du type declare.
        DECL^typeLeft := TYPE^type;
        -- Propagation du nom de l'ident de gauche.
        DECL^name := ident^txt;
    end
end
} -- }}}

-- Enregistrement de la declaration dans la table des symboles.
#record { -- {{{
local
    t : TYPE;
do
    -- Calcul du type de la variable/fonction.
    if DECL^varF = null then
        -- Enregistrement effectif de la variable dans la tds.
        ENTITE^tds.putVar(ident^txt, TYPE^type);
    else
        t := DECL^varF.type();
        -- Enregistrement du type de la fonction dans la table des types.
        ENTITE^tds.putType(t.name(), t);
        -- Enregistrement effectif de la fonction dans la tds.
        ENTITE^tds.putVar(ident^txt, DECL^varF);
    end
end
} -- }}}

-- Recuperation du code de la declaration.
#code { -- {{{
do
    ENTITE^code := DECL^code;
end
} -- }}}

--
--
-- -- Declaration
--
--

--
--
-- Fin de la declaration (variable).
DECL -> #type #code pv ;

-- Pas de fonction sous-jacente.
#type { -- {{{
do
    DECL^varF := null;
end
} -- }}}

-- Generation du code pour une declaration de variable.
#code { -- {{{
local
    h : HelperMemoryInterface;
do
    h := DECL^gen.getMemoryHelper();
    DECL^code := h.generateReserve(DECL^typeLeft.size());
end
} -- }}}

--
--
-- Fin de la declaration (fonction).
DECL -> #type FONCTION #code ;

-- Creation du type de la fonction et de la VAR correspondante.
#type { -- {{{
local
    f : FCT;
    t : FTYPE;
do
    -- Creation du type a partir du type de retour de la fonction.
    t := new FTYPE(DECL^typeLeft);
    -- Creation de la VAR representant la fonction.
    f := new FCT(t, DECL^tds, DECL^name);
    -- Propagation de la VAR a DECL pour enregistrement dans la TDS (de la VAR ET du type associe).
    DECL^varF := f;
    -- Transmission de la VAR a FONCTION pour reellement generer la fonction et son type
    FONCTION^fct := f;
end
} -- }}}

-- Generation du code pour une declaration de fonction.
#code { -- {{{
local
    h : HelperFunctionInterface;
do
    h := DECL^gen.getFunctionHelper();
    DECL^code := h.generateFunction(DECL^name, DECL^name, FONCTION^code);
end
} -- }}}

--
--
-- -- Fonction
--
--

--
--
-- Debut de la premiere ligne d'une fonction.
FONCTION -> paro PARFS parf #type1 BLOC #type2 #code ;
global
    tFct : FTYPE;

-- Transmission de la TDS interne de la fonction au corps de fonction.
#type1 { -- {{{
local
    tds : TDS;
do
    tds := FONCTION^fct.tds();
    -- Termine l'ajout des parametres a la fonction.
    tds.endFunctionDeclaration();
    BLOC^tds := tds;
end
} -- }}}

-- Verification du type de retour de la fonction.
#type2 { -- {{{
local
    tReturn : TYPE;
do
    tFct := FONCTION^fct.type();
    tReturn := tFct.retType();
    if tReturn /= BLOC^type then
        error(MCS_BAD_TYPE_6, tReturn.name(), BLOC^type.name());
    end
end
} -- }}}

-- Recuperation du code du corps de la fonction
-- Insertion d'un return artificiel au cas ou il n'y en aurait pas.
#code { -- {{{
local
    h : HelperFunctionInterface;
do
    h := FONCTION^gen.getFunctionHelper();
    FONCTION^code := BLOC^code + h.generateReturn(tFct.sizeParams(), 0, "artificiel pour " + FONCTION^fct.name());
end
} -- }}}

--
--
-- Fonction sans aucun parametres.
PARFS -> ;

--
--
-- Premier parametre la fonction.
PARFS -> PARF PARFSX ;
-- Transmission implicite de PARFS^fct.

--
--
-- Fin de la liste de parametres.
PARFSX -> ;

--
--
-- Fonction : parametre supplémentaire.
PARFSX -> virg PARF PARFSX ;
-- Transmission implicite de PARFSX^fct.

--
--
-- Evaluation d'un parametre de fonction (typage et enregistrement).
PARF -> TYPE ident #type #record ;

-- Enregistrement du type du parametre de la fonction.
#type { -- {{{
local
    t : FTYPE;
do
    t := PARF^fct.type();
    -- Ajout du type du parametre dans le type de la fonction.
    -- Attention : a faire avant d'enregistrer le parametre dans la liste des parametres !
    t.putParam(TYPE^type);
end
} -- }}}

-- Enregistrement du parametre dans la liste de parametres de la fonction.
#record { -- {{{
local
    f : FCT;
do
    f := PARF^fct;
    -- Verifier qu'aucun parametre du meme nom n'est pas deja defini.
    if f.contains(ident^txt) then
        error(MCS_PAE, ident^txt);
    else
        -- Ajout du parametre dans la liste de parametres de la fonction.
        f.putParam(ident^txt);
    end
end
} -- }}}

--
--
-- -- Types
--
--

--
--
-- Structure d'un type, pointeur ou non.
TYPE -> STYPE #type1 PTRS #type2 ;

-- Propagation du premier type.
#type1 { -- {{{
local
do
    PTRS^typeLeft := STYPE^type;
end
} -- }}}

-- Propagation du second type.
#type2 { -- {{{
local
do
    TYPE^type := PTRS^type;
end
} -- }}}

--
--
-- Pointeur, fin de la liste d'etoile.
PTRS -> #type ;

-- Propagation du type du pointeur.
#type { -- {{{
local
do
    PTRS^type := PTRS^typeLeft;
end
} -- }}}

--
--
-- Pointeur, une etoile de plus dans la liste d'etoiles.
PTRS -> mult PTRS #type ;

-- Ajout du type a la table des symboles.
#type { -- {{{
local
    t : PTR;
    o : TYPE;
do
    -- Instanciation d'un type pointeur.
    t := new PTR(PTRS1^type);

    -- Recherche du type pointeur dans la table des types.
    o := PTRS^tds.searchType(t.name(), true);

    -- Propagation du type.
    if o /= null then
        -- L'instance precedemment creee.
        PTRS^type := o;
    else
        -- L'instance nouvellement creee.
        PTRS^type := t;
        -- Ajout du type dans la TDS.
        PTRS^tds.putType(t.name(), t);
    end
end
} -- }}}

--
--
-- Types de base (void)
STYPE-> void #type ;

-- Les types de base sont deja presents dans la TDS.
#type { -- {{{
local
do
    STYPE^type := STYPE^tds.searchType("void", true);
end
} -- }}}

--
--
-- Types de base (int)
STYPE-> int #type ;

-- Les types de base sont deja presents dans la TDS.
#type { -- {{{
local
do
    STYPE^type := STYPE^tds.searchType("int", true);
end
} -- }}}

--
--
-- Types de base (char)
STYPE-> char #type ;

-- Les types de base sont deja presents dans la TDS.
#type { -- {{{
local
do
    STYPE^type := STYPE^tds.searchType("char", true);
end
} -- }}}

--
--
-- Identificateur d'un type (pour les types nommes par le codeur).
STYPE -> identc #type ;

-- Resolution du type nomme dans la TDS.
#type { -- {{{
local
    t : TYPE;
do
    t := STYPE^tds.searchType(identc^txt, true);
    if t = null then
        error(MCS_TUN, identc^txt);
    else
        STYPE^type := t;
    end
end
} -- }}}

--
--
-- Type d'une struct.
STYPE -> #type struct aco CHAMPS acf ;

-- Creation du type struct initial (vide).
#type { -- {{{
local
    s : STRUCT;
do
    s := new STRUCT();
    CHAMPS^typeCHP := s;
    STYPE^type := s;
end
} -- }}}

--
--
-- Fin de l'evaluation du type struct.
CHAMPS -> ;

--
--
-- Evaluation du type struct, liste de champ.
CHAMPS -> CHAMP CHAMPS ;

--
--
-- Decomposition du contenu d'un champ.
CHAMP -> TYPE ident pv #type ;

-- Enregistrement du type d'un champ dans la TPS de la struct.
#type { -- {{{
local
    v : VAR ;
do
    -- Verifier qu'aucune fonction/variable du meme nom n'est pas deja definie
    -- localement dans la struct.
    v := CHAMP^typeCHP.searchVar(ident^txt);
    if v /= null then
        error(MCS_DAE, ident^txt);
    else
        -- Enregistrement effectif de la declaration.
        CHAMP^typeCHP.putVar(ident^txt, TYPE^type);
    end
end
} -- }}}

--
--
-- -- Bloc de code
--
--

--
--
-- Delimitation d'un bloc de code.
BLOC -> aco INSTS acf #type #code ;

-- Le type propage est non-null si le bloc contient une instruction " return ".
#type { -- {{{
local
do
    BLOC^type := INSTS^type;
end
} -- }}}

#code { -- {{{
do
    BLOC^code := INSTS^code;
end
} -- }}}

--
--
-- Instruction vide, effet de bord.
INSTS -> #type #code ;

-- Un effet de bord ne retourne rien, type null.
#type { -- {{{
local
do
    INSTS^type := null;
end
} -- }}}

-- Pas de code genere.
#code { -- {{{
do
    INSTS^code := "";
end
} -- }}}

--
--
-- Ajout d'une instruction dans le bloc.
INSTS -> INST INSTS #type #code ;

-- Le type d'une instruction INST (differente d'une expression E) est soit :
--    - null (effet de bord).
--    - Resultat d'un return.
#type { -- {{{
local
do
    -- Le type d'une liste d'instructions INSTS est le type de la premiere INST
    --     de type non-null (i.e. du premier return de la sequence).
    if INST^type /= null then
        INSTS^type := INST^type;
    else
        INSTS^type := INSTS1^type;
    end
end
} -- }}}

-- Concatenation du code genere pour les differentes instructions.
#code { -- {{{
do
    INSTS^code := INST^code + INSTS1^code;
end
} -- }}}

--
--
-- Declaration d'une variable locale, avec ou sans initialisation.
INST -> TYPE ident #record AFFX pv #type #code ;

-- Enregistrement de la variable dans la TDS du bloc.
#record { -- {{{
local
    v : VAR;
do
    v := INST^tds.searchVar(ident^txt, false);
    if v /= null then
        error(MCS_DAE);
    else
        INST^tds.putVar(ident^txt, TYPE^type);
    end
end
} -- }}}

-- Typage de l'instruction et verification du type de l'affectation.
#type { -- {{{
local
do
    -- Une declaration ou une affectation est un effet de bord, pas de type.
    INST^type := null;

    -- Verification du type de l'affectation.
    if AFFX^type /= null && AFFX^type /= TYPE^type then
        error(MCS_BAD_TYPE_2, TYPE^type.name(), AFFX^type.name(), ident^txt);
    end
end
} -- }}}

-- Recuperation du code genere.
#code { -- {{{
local
    h : HelperMemoryInterface;
do
    h := INST^gen.getMemoryHelper();
    if AFFX^type = null then
        -- Generation du code pour une declaration sans initialisation.
        INST^code := h.generateReserve(TYPE^type.size());
    else
        -- Generation du code pour une declaration avec initialisation (recuperation de la rightValue).
        INST^code := AFFX^code;
    end
end
} -- }}}

--
--
-- Instruction " expression " (affectation et appel de procedure).
INST -> E pv #type #code ;

-- Une expression seule est un effet de bord, pas de type.
#type { -- {{{
local
do
    INST^type := null;
end
} -- }}}

-- Recuperation du code genere.
#code { -- {{{
local
    h : HelperMemoryInterface;
do
    h := INST^gen.getMemoryHelper();
    -- La valeur de l'expression E est inutile, il faut donc la depiler.
    INST^code := E^code + h.generateFree(E^type.size());
end
} -- }}}

--
--
-- Un nouveau bloc est insere en instruction.
INST -> #type1 BLOC #type2 #code ;

-- Creation d'une TDS locale au bloc.
#type1 { -- {{{
local
    tds : TDS;
do
    tds := new TDS(INST^tds, false);
    BLOC^tds := tds;
end
} -- }}}

-- Un nouveau bloc est insere en instruction, si il est dote d'un type de
-- retour, il contient un " return ", et son type se propage
#type2 { -- {{{
local
do
    INST^type := BLOC^type;
end
} -- }}}

-- Recuperation du code genere.
#code { -- {{{
do
    INST^code := BLOC^code;
end
} -- }}}

--
--
-- Bloc conditionnel.
INST -> si paro E parf #type1 BLOC SIX #type2 #code ;

-- Creation d'une TDS locale au bloc.
#type1 { -- {{{
local
    tds : TDS;
do
    tds := new TDS(INST^tds, false);
    BLOC^tds := tds;
end
} -- }}}

-- Le type du bloc conditionnel correspond au type de retour commun.
#type2 { -- {{{
local
do
    -- Une expression conditionnelle est de type de retour entier.
    if E^type /= INST^tds.searchType("int", true) then
        error(MCS_NOT_BOOLEAN, E^type.name());
    else
        if BLOC^type /= null then
            if SIX^type /= null then
                if BLOC^type /= SIX^type then
                    -- Les deux bloc renvoient des types differents, erreur.
                    error(MCS_BAD_TYPE, BLOC^type.name(), SIX^type.name());
                else
                    -- Les deux blocs existent et renvoient le meme type.
                    INST^type := BLOC^type;
                end
            else
                -- Pas de deuxieme bloc, ou un bloc d'effets de bord.
                INST^type := BLOC^type;
            end
        else
            -- Le premier bloc ne contient que des effets de bord.
            -- (On utilise le type de retour de SIX)
            INST^type := SIX^type;
        end
    end
end
} -- }}}

-- Generation du code pour le if.
#code { -- {{{
local
    h : HelperGeneralInterface;
do
    h := INST^gen.getGeneralHelper();
    INST^code := h.generateIf(E^code, BLOC^code, SIX^code);
end
} -- }}}

--
--
-- Bloc sinon.
SIX -> sinon #type1 BLOC #type2 #code ;

-- Creation d'une TDS locale au bloc.
#type1 { -- {{{
local
    tds : TDS;
do
    tds := new TDS(SIX^tds, false);
    BLOC^tds := tds;
end
} -- }}}

-- Propagation du type.
#type2 { -- {{{
local
do
    SIX^type := BLOC^type;
end
} -- }}}

-- Recuperation du code genere.
#code { -- {{{
do
    SIX^code := BLOC^code;
end
} -- }}}

--
--
-- Pas de bloc suivant dans la conditionnelle.
SIX -> #type #code ;

-- Pas de bloc, considere comme un effet de bord.
#type { -- {{{
local
do
    SIX^type := null;
end
} -- }}}

-- Recuperation du code genere.
#code { -- {{{
do
    SIX^code := "";
end
} -- }}}

--
--
-- L'instruction retourne un type, un " return de fonction ".
INST -> retour E pv #type #code ;
#type { -- {{{
local
    fct : FTYPE;
    t : TYPE;
do
    -- Verification que le type retourne correspond au type de retour de la fonction.
    fct := INST^fct.type();
    t := fct.retType();
    if t /= E^type then
        error(MCS_BAD_TYPE_6, t.name(), E^type.name());
    else
        -- Instruction return : on transfere le type de l'expression renvoyee.
        INST^type := E^type;
    end
end
} -- }}}

#code { -- {{{
local
    h : HelperFunctionInterface;
    tFct : FTYPE;
do
    h := INST^gen.getFunctionHelper();
    tFct := INST^fct.type();
    INST^code := E^code + h.generateReturn(tFct.sizeParams(), E^type.size(), "explicite pour " + INST^fct.name());
end
} -- }}}

--
--
-- -- Expressions
--
--

-------------------------------------------------------------------------
-- Lexique                                                              -
-------------------------------------------------------------------------
-- E = Expression (y compris l'affectation)                             -
-- A = Expression figurant dans une affectation                         -
-- R = Expression figurant dans une expresion relationnelle             -
-- T = Expression figurant dans une expression additive (TERME)         -
-- F = Expression figurant dans une expression multiplicative (FACTEUR) -
-------------------------------------------------------------------------

--
--
-- Expression qui affecte.
E -> A AFFX #type #code ;

-- Verification du type des affectations.
#type { -- {{{
local
do
    if AFFX^type /= null && AFFX^type /= A^type then
        error(MCS_BAD_TYPE_2_BIS, A^type.name(), AFFX^type.name());
    else
        E^type := A^type;
    end
end
} -- }}}

#code { -- {{{
local
    h : HelperMemoryInterface;
do
    h := E^gen.getMemoryHelper();
    if AFFX^type /= null then
        -- Affectation
        -- Duplication de AFFX^code sur la pile pour que le resultat d'une affectation soit la valeur affectee.
        E^code := AFFX^code + h.generateDuplicate(AFFX^type.size()) + A^leftCode + h.generateDynamicWrite(AFFX^type.size());
    else
        -- Recuperation simple de la valeur d'une expression (de meme que pour une rightValue).
        E^code := A^rightCode;
    end
end
} -- }}}

--
--
-- Affectation
AFFX -> affect A #type #code ;

-- Verification du type des affectations (suite).
#type { -- {{{
local
do
    AFFX^type := A^type;
end
} -- }}}

-- Generation du code pour une declaration avec initialisation : on utilise le code genere pour A.
#code { -- {{{
local
do
    AFFX^code := A^rightCode;
end
} -- }}}

--
--
-- Fin d'une affectation.
AFFX -> #type #code ;

-- Verification du type des affectations (fin).
#type { -- {{{
local
do
    AFFX^type := null;
end
} -- }}}

-- Generation du code pour une absence de rightValue.
#code { -- {{{
do
    AFFX^code := "";
end
} -- }}}

--
--
-- Relation, moins prioritaire que A.
A -> R AX #type #code;

-- Verification du type d'une relation.
#type { -- {{{
local
do
    if AX^type /= null then
        if AX^type /= R^type then
            error(MCS_BAD_TYPE_3, R^type.name(), AX^type.name());
        else
            -- Condition : type int ou bool selon la version.
            A^type := A^tds.searchType("int", true);
        end
    else
        -- Pas de comparaison, utilisation du type de R.
        A^type := R^type;
    end
end
} -- }}}

-- Generation du code d'une relation.
#code { -- {{{
local
do
    if AX^type /= null & AX^type = R^type then
        -- A est une condition booleenne donc forcement une rightValue...
        A^leftCode := "";
        -- La comparaison est faite dans le code de AX.
        A^rightCode := R^rightCode + AX^code;
    else
        -- On ne prend pas en compte ici l'erreur de type ayant deja ete traitee au dessus.
        -- On recupere les deux types de code generes (pas de comparaison a ce niveau).
        A^leftCode := R^leftCode;
        A^rightCode := R^rightCode;
    end
end
} -- }}}

--
--
-- Operateur relationnel.
AX -> OPREL R #type #code ;

-- Verification du type d'une relation (suite).
#type { -- {{{
local
do
    -- Les operateurs relationels de base utilisent des entiers.
    if R^type /= AX^tds.searchType("int", true) then
        error(MCS_BAD_TYPE_3, "int", R^type.name());
    else
        AX^type := R^type;
    end
end
} -- }}}

-- Generation de code pour une relation (suite).
#code { -- {{{
do
    -- La comparaison a lieu ici.
    -- OPREL^code contient l'appel a l'operateur de comparaison.
    AX^code := R^rightCode + OPREL^code;
end
} -- }}}

--
--
-- Fin de la relation.
AX -> #type #code ;

-- Verification du type d'une relation (fin).
#type { -- {{{
local
do
    AX^type := null;
end
} -- }}}

-- Pas de code genere.
#code { -- {{{
do
    AX^code := "";
end
} -- }}}

--
--
-- Operateurs relationnels.
OPREL -> inf #code ;

-- Generation de code : appel de la subroutine correspondante.
#code { -- {{{
local
    h : HelperIntInterface;
do
    h := OPREL^gen.getIntHelper();
    OPREL^code := h.generateLss();
end
} -- }}}

OPREL -> sup #code ;

-- Generation de code : appel de la subroutine correspondante.
#code { -- {{{
local
    h : HelperIntInterface;
do
    h := OPREL^gen.getIntHelper();
    OPREL^code := h.generateGtr();
end
} -- }}}

OPREL -> infeg #code ;

-- Generation de code : appel de la subroutine correspondante.
#code { -- {{{
local
    h : HelperIntInterface;
do
    h := OPREL^gen.getIntHelper();
    OPREL^code := h.generateLeq();
end
} -- }}}

OPREL -> supeg #code ;

-- Generation de code : appel de la subroutine correspondante.
#code { -- {{{
local
    h : HelperIntInterface;
do
    h := OPREL^gen.getIntHelper();
    OPREL^code := h.generateGeq();
end
} -- }}}

OPREL -> eg #code ;

-- Generation de code : appel de la subroutine correspondante.
#code { -- {{{
local
    h : HelperIntInterface;
do
    h := OPREL^gen.getIntHelper();
    OPREL^code := h.generateEq();
end
} -- }}}

OPREL -> neg #code ;

-- Generation de code : appel de la subroutine correspondante.
#code { -- {{{
local
    h : HelperIntInterface;
do
    h := OPREL^gen.getIntHelper();
    OPREL^code := h.generateNeq();
end
} -- }}}

--
--
-- Terme.
R -> T RX #type #code;

-- Verification du type d'une operation additive.
#type { -- {{{
local
do
    if RX^type /= null && RX^type /= T^type then
        error(MCS_BAD_TYPE_4, T^type.name(), RX^type.name());
    else
        R^type := T^type;
    end
end
} -- }}}

-- Generation du code d'une operation additive.
#code { -- {{{
local
do
    if RX^type /= null & RX^type = T^type then
        -- R contient une addition donc est forcement une rightValue...
        R^leftCode := "";
        -- L'addition est faite dans le code de RX.
        R^rightCode := T^rightCode + RX^code;
    else
        -- On ne prend pas en compte ici l'erreur de type ayant deja ete traitee au dessus.
        -- On recupere les deux types de code generes (pas d'addition a ce niveau).
        R^leftCode := T^leftCode;
        R^rightCode := T^rightCode;
    end
end
} -- }}}

--
--
-- Additions ...
RX -> OPADD T RX #type #code;

-- Verification du type d'une operation additive (suite).
#type { -- {{{
local
do
    if RX1^type /= null && RX1^type /= T^type then
        error(MCS_BAD_TYPE_4, T^type.name(), RX1^type.name());
    else
        -- Les operateurs additifs de base utilisent des entiers.
        if T^type /= RX^tds.searchType("int", true) then
            error(MCS_BAD_TYPE_4, "int", T^type.name());
        else
            RX^type := T^type;
        end
    end
end
} -- }}}

-- Generation du code pour les operations additives (suite).
#code { -- {{{
local
    h : HelperIntInterface;
do
    h := RX^gen.getIntHelper();
    -- L'operation additive a lieu ici.
    -- OPADD^code contient l'appel a l'operateur.
    if OPADD^toBool then
        -- Si l'operateur utilise necessite une conversion prealable en booleen.
        RX^code := h.generateIntToBool() + T^rightCode + h.generateIntToBool() + OPADD^code + RX1^code;
    else
        RX^code := T^rightCode + OPADD^code + RX1^code;
    end
end
} -- }}}

--
--
-- Fin d'une addition.
RX -> #type #code;

-- Verification du type d'une operation additive (fin).
#type { -- {{{
local
do
    RX^type := null;
end
} -- }}}

-- Pas de code genere.
#code { -- {{{
do
    RX^code := "";
end
} -- }}}

--
--
-- Operateurs additifs.

OPADD -> plus #code ;

-- Generation de code : appel de la subroutine correspondante.
#code { -- {{{
local
    h : HelperIntInterface;
do
    h := OPADD^gen.getIntHelper();
    OPADD^code := h.generateSum();
    OPADD^toBool := false;
end
} -- }}}

OPADD -> moins #code ;

-- Generation de code : appel de la subroutine correspondante.
#code { -- {{{
local
    h : HelperIntInterface;
do
    h := OPADD^gen.getIntHelper();
    OPADD^code := h.generateSub();
    OPADD^toBool := false;
end
} -- }}}

OPADD -> ou #code ;

-- Generation de code : appel de la subroutine correspondante.
#code { -- {{{
local
    h : HelperBoolInterface;
do
    h := OPADD^gen.getBoolHelper();
    OPADD^code := h.generateOr();
    OPADD^toBool := true;
end
} -- }}}

--
--
-- Multiplication, ...
T -> F TX #type #code;

-- Verification du type d'une operation multiplicative.
#type { -- {{{
local
do
    if TX^type /= null && TX^type /= F^type then
        error(MCS_BAD_TYPE_5, F^type.name(), TX^type.name());
    else
        T^type := F^type;
    end
end
} -- }}}

-- Generation du code d'une operation multiplicative.
#code { -- {{{
local
do
    if TX^type /= null && TX^type = F^type then
        -- T contient une multiplication donc est forcement une rightValue...
        T^leftCode := "";
        -- La multiplication est faite dans le code de TX.
        T^rightCode := F^rightCode + TX^code;
    else
        -- On ne prend pas en compte ici l'erreur de type ayant deja ete traitee au dessus.
        -- On recupere les deux types de code generes (pas de multiplication).
        T^leftCode := F^leftCode;
        T^rightCode := F^rightCode;
    end
end
} -- }}}

--
--
-- Suite de la multiplication.
TX -> OPMUL F TX #type #code;

-- Verification du type d'une operation multiplicative (suite).
#type { -- {{{
local
do
    if TX1^type /= null && TX1^type /= F^type then
        error(MCS_BAD_TYPE_5, F^type.name(), TX1^type.name());
    else
        -- Les operateurs multiplicatifs de base utilisent des entiers.
        if F^type /= TX^tds.searchType("int", true) then
            error(MCS_BAD_TYPE_5, "int", F^type.name());
        else
            TX^type := F^type;
        end
    end
end
} -- }}}

-- Generation du code pour les operations multiplicatives (suite).
#code { -- {{{
local
    h : HelperIntInterface;
do
    h := TX^gen.getIntHelper();
    -- L'operation multiplicative a lieu ici.
    -- OPMUL^code contient l'appel a l'operateur.
    if OPMUL^toBool then
        -- Si l'operateur utilise necessite une conversion prealable en booleen.
        TX^code := h.generateIntToBool() + F^rightCode + h.generateIntToBool() + OPMUL^code + TX1^code;
    else
        TX^code := F^rightCode + OPMUL^code + TX1^code;
    end
end
} -- }}}

--
--
-- Fin de la multiplication.
TX -> #type #code;

-- Verification du type d'une operation multiplicative (fin).
#type { -- {{{
local
do
    TX^type := null;
end
} -- }}}

-- Pas de code genere.
#code { -- {{{
do
    TX^code := "";
end
} -- }}}

--
--
-- Operateurs multiplicatifs.

OPMUL -> mult #code ;

-- Generation de code : appel de la subroutine correspondante.
#code { -- {{{
local
    h : HelperIntInterface;
do
    h := OPMUL^gen.getIntHelper();
    OPMUL^code := h.generateMul();
    OPMUL^toBool := false;
end
} -- }}}

OPMUL -> div #code ;

-- Generation de code : appel de la subroutine correspondante.
#code { -- {{{
local
    h : HelperIntInterface;
do
    h := OPMUL^gen.getIntHelper();
    OPMUL^code := h.generateDiv();
    OPMUL^toBool := false;
end
} -- }}}

OPMUL -> mod #code ;

-- Generation de code : appel de la subroutine correspondante.
#code { -- {{{
local
    h : HelperIntInterface;
do
    h := OPMUL^gen.getIntHelper();
    OPMUL^code := h.generateMod();
    OPMUL^toBool := false;
end
} -- }}}

OPMUL -> et #code ;

-- Generation de code : appel de la subroutine correspondante.
#code { -- {{{
local
    h : HelperBoolInterface;
do
    h := OPMUL^gen.getBoolHelper();
    OPMUL^code := h.generateAnd();
    OPMUL^toBool := true;
end
} -- }}}

--
--
-- -- Expressions de base
--
--

--
--
-- Constante entiere
F -> entier #type #code;

-- Une constante entiere a un type entier.
#type { -- {{{
local
do
    F^type := F^tds.searchType("int", true);
end
} -- }}}

-- Generation de code pour une constante entiere.
#code { -- {{{
local
    h : HelperGeneralInterface;
do
    h := F^gen.getGeneralHelper();
    -- Une constante est necessairement une rightValue.
    -- TODO: Declencher une erreur de compilation si la constante est utilisee en tant que leftValue.
    F^leftCode := "";
    F^rightCode := h.generateConstante(entier^txt);
end
} -- }}}

--
--
-- Constante chaine
F -> chaine #type #code ;

-- Une const-chaîne a un type de pointeur-sur-char.
#type { -- {{{
local
do
    F^type := F^tds.searchType("char*", true);
end
} -- }}}

-- Generation de code pour une constante chaine.
#code { -- {{{
local
    h : HelperStringInterface;
do
    h := F^gen.getStringHelper();
    -- Une constante est necessairement une rightValue.
    -- TODO: Declencher une erreur de compilation si la constante est utilisee en tant que leftValue.
    F^leftCode := "";
    F^rightCode := h.generateNew(chaine^txt);
end
} -- }}}

--
--
-- Constante caractere
F -> caractere #type #code;

-- Type char.
#type { -- {{{
local
do
    F^type := F^tds.searchType("char", true);
end
} -- }}}

-- Generation de code pour une constante caractere.
#code { -- {{{
local
    h : HelperGeneralInterface;
do
    h := F^gen.getGeneralHelper();
    -- Une constante est necessairement une rightValue.
    -- TODO: Declencher une erreur de compilation si la constante est utilisee en tant que leftValue.
    F^leftCode := "";
    F^rightCode := h.generateConstante(caractere^txt);
end
} -- }}}


--
--
-- Expression unaire
F -> OPUN F #type #code ;

-- Propagation du type.
#type { -- {{{
local
do
    F^type := F1^type;
end
} -- }}}

-- Generation de code pour une operation unaire.
#code { -- {{{
do
    -- F fait intervenir une operation, donc est forcement une rightValue.
    F^leftCode := "";
    -- OPUN^code contient l'appel a l'operateur.
    F^rightCode := F1^rightCode + OPUN^code;
end
} -- }}}

--
--
-- Operateurs unaires

OPUN -> plus #code ;

-- Generation de code : appel de la subroutine correspondante.
#code { -- {{{
do
    -- Rien a faire en particulier.
    OPUN^code := "";
end
} -- }}}

OPUN -> moins #code ;

-- Generation de code : appel de la subroutine correspondante.
#code { -- {{{
local
    hi : HelperIntInterface;
    hg : HelperGeneralInterface;
do
    hi := OPUN^gen.getIntHelper();
    hg := OPUN^gen.getGeneralHelper();
    -- Multiplication par -1.
    OPUN^code := hg.generateComment("Multiplication par -1.") + hg.generateConstante("-1") + hi.generateMul();
end
} -- }}}

OPUN -> non #code ;

-- Generation de code : appel de la subroutine correspondante.
#code { -- {{{
local
    h : HelperIntInterface;
do
    h := OPUN^gen.getIntHelper();
    OPUN^code := h.generateNeg();
end
} -- }}}

--
--
-- Pointeur NULL
F -> null #type #code;

-- Type du pointeur null.
#type { -- {{{
local
do
    -- TODO: Verifier le bon fonctionnement :
    -- Type null compatible avec les autres dans la verification de type ?
    F^type := null;
end
} -- }}}

-- Generation de code pour le pointeur null.
#code { -- {{{
local
    h : HelperMemoryInterface;
do
    h := F^gen.getMemoryHelper();
    -- F est une constante (null) donc forcement une rightValue...
    F^leftCode := "";
    F^rightCode := h.generateVoid();
end
} -- }}}

--
--
-- Expression parenthesee
F -> paro E parf #type1 FX #type2 #code;

-- Recuperation du type evalue.
#type1 { -- {{{
local
do
    FX^typeLeft := E^type;
    FX^name := null;
end
} -- }}}

-- Propagation du type.
#type2 { -- {{{
local
do
    F^type := FX^type;
end
} -- }}}

-- Generation de code pour une expression parenthesee.
#code { -- {{{
local
do
    -- A priori simple concatenation du code.
    -- TODO: Verifier le bon fonctionnement.
    F^leftCode := E^code + FX^leftCode;
    F^rightCode := E^code + FX^rightCode;
end
} -- }}}

--
--
-- Cast explicite.
F -> paro TYPE parf F #type #code ;

-- Cast explicite : on n'utilise pas le type de F.
#type { -- {{{
local
do
    warning(MCS_WAR_CAST, F1^type.name(), TYPE^type.name());
    if TYPE^type.size() /= F1^type.size() then
        error(MCS_BAD_CAST, F1^type.name(), TYPE^type.name(), F1^type.size(), TYPE^type.size());
    else
        F^type := TYPE^type;
    end
end
} -- }}}

-- Generation de code pour un cast.
#code { -- {{{
local
do
    -- Transmission du code genere, sans traitement supplementaire.
    F^leftCode := F1^leftCode;
    F^rightCode := F1^rightCode;
end
} -- }}}

--
--
-- Typage d'un dereferencement avec *.
F -> mult F #type #code;
global
    -- Type pointe.
    pt : TYPE;

-- Typage d'une expression contenant *.
#type { -- {{{
local
    p : PTR;
do
    if !(F1^type.isPointer()) then
        error(MCS_NOT_PTR, F1^type.name());
    else
        p := F1^type.toPointer();
        pt := p.ptype();
        F^type := pt;
    end
end
} -- }}}

-- Generation de code pour un acces valeur pointee.
#code { -- {{{
local
    h : HelperMemoryInterface;
do
    h := F^gen.getMemoryHelper();
    -- F -> *a ; a = F1
    -- F1^rightCode contient le contenu de a, soit l'adresse de la zone pointee.
    -- On n'a a priori pas besoin de F1^leftCode qui est l'adresse de a.
    F^leftCode := F1^rightCode;
    -- Attention : on utilise bien ici pt (type pointe) et non F1^type (type pointeur).
    F^rightCode := F1^rightCode + h.generateDynamicRead(pt.size());
end
} -- }}}

--
--
-- Utilisation d'un ident.
F -> ident #type1 FX #type2 #code;
global
    -- Variable correspondant a l'ident.
    v : VAR;

-- Typage  et verification de l'existence de la variable.
#type1 { -- {{{
do
    v := F^tds.searchVar(ident^txt, true);
    if v = null then
        error(MCS_VUN, ident^txt);
    else
        FX^typeLeft := v.type();
        FX^name := ident^txt;
    end
end
} -- }}}
-- Recuperation du type evalue.
#type2 { -- {{{
local
do
    F^type := FX^type;
end
} -- }}}

-- Generation de code pour un acces a une variable.
#code { -- {{{
local
    hm : HelperMemoryInterface;
    hg : HelperGeneralInterface;
    t : TYPE;
    a : Address;
do
    hm := F^gen.getMemoryHelper();
    hg := F^gen.getGeneralHelper();
    t := v.type();
    a := v.addr();
    if FX^endl then
        -- Empilement de l'adresse de la variable.
        F^leftCode := hg.generateConstante(a.val());
        -- Empilement de la valeur de la variable.
        F^rightCode := hm.generateStaticRead(a.val(), t.size(), a.ref());
    else
        if t.isStruct() then
            -- La differenciation effective se fera lors la generation du code de FX.
            -- Empilement de l'adresse de l'enregistrement puis de l'adresse du champ.
            F^leftCode := hg.generateConstante(a.val()) + FX^leftCode;
            -- Empilement de l'adresse de l'enregistrement puis de la valeur du champ.
            F^rightCode := hg.generateConstante(a.val()) + FX^rightCode;
        elseif t.isPointer() then
            -- La differenciation effective se fera lors la generation du code de FX.
            -- Empilement de l'adresse de la zone pointee, puis de l'adresse du champ.
            F^leftCode := hm.generateStaticRead(a.val(), t.size(), a.ref()) + FX^leftCode;
            -- Empilement de l'adresse de la zone pointee puis de la valeur du champ.
            F^rightCode := hm.generateStaticRead(a.val(), t.size(), a.ref()) + FX^rightCode;
        elseif t.isFType() then
            -- TODO: Verifier code genere correct dans toutes situations.
            F^leftCode := FX^leftCode;
            F^rightCode := FX^rightCode;
        end
    end
end
} -- }}}

--
--
-- Fin d'evaluation du type d'un facteur.
FX -> #type #code;

-- Propagation du type racine.
#type { -- {{{
local
    ft : FTYPE;
do
    -- En cas d'appel de fonction, le type resultant est le type de retour de la fonction
    -- et non le type de la fonction lui-meme.
    if (FX^typeLeft.isFType()) then
        ft := FX^typeLeft.toFType();
        FX^type := ft.retType();
    else
        -- Propagation du type.
        FX^type := FX^typeLeft;
    end
end
} -- }}}

-- Generation de code pour une fin d'expression.
#code { -- {{{
local
do
    FX^leftCode := "";
    FX^rightCode := "";
    FX^endl := true;
end
} -- }}}

--
--
-- Acces champ
FX -> pt ident #type1 FX #type2 #code;
global
    -- Champ accede.
    c : VAR;

-- Verification du type racine.
#type1 { -- {{{
local
    p : STRUCT;
do
    if !(FX^typeLeft.isStruct()) then
        error(MCS_NOT_STRUCT, FX^typeLeft.name());
    else
        p := FX^typeLeft.toStruct();
        c := p.searchVar(ident^txt);
        if c = null then
            error(MCS_UNKNOWN_FIELD, ident^txt);
        else
            FX1^typeLeft := c.type();
        end
    end
end
} -- }}}

-- Recuperation du type
#type2 { -- {{{
local
do
    FX^type := FX1^type;
end
} -- }}}

-- Generation de code pour un acces champ.
#code { -- {{{
local
    hm : HelperMemoryInterface;
    hg : HelperGeneralInterface;
    hi : HelperIntInterface;
    -- Type du champ accede.
    t : TYPE;
    -- Adresse relative du champ accede.
    a : Address;
    -- Code de calcul de l'adresse absolue du champ accede.
    codeCommun : String;
do
    hm := FX^gen.getMemoryHelper();
    hg := FX^gen.getGeneralHelper();
    hi := FX^gen.getIntHelper();
    FX^endl := false;
    t := c.type();
    a := c.addr();
    -- Le code commun empile l'adresse du champ utilise.
    codeCommun := hg.generateConstante(a.val()) + hi.generateSum();
    if FX1^endl then
        -- Empilement de l'adresse de la variable (adresse du champ).
        FX^leftCode := codeCommun;
        -- Empilement de la valeur de la variable (valeur du champ).
        FX^rightCode := codeCommun + hm.generateDynamicRead(t.size());
    else
        if t.isStruct() then
            -- La differenciation effective se fera lors la generation du code de FX.
            -- Empilement de l'adresse de l'enregistrement (premier niveau de champ) puis de l'adresse du champ.
            FX^leftCode := codeCommun + FX1^leftCode;
            -- Empilement de l'adresse de l'enregistrement (premier niveau de champ) puis de la valeur du champ.
            FX^rightCode := codeCommun + FX1^rightCode;
        elseif t.isPointer() then
            -- La differenciation effective se fera lors la generation du code de FX.
            -- Empilement de l'adresse de la zone pointee, puis de l'adresse du champ.
            FX^leftCode := codeCommun + hm.generateDynamicRead(t.size()) + FX1^leftCode;
            -- Empilement de l'adresse de la zone pointee puis de la valeur du champ.
            FX^rightCode := codeCommun + hm.generateDynamicRead(t.size()) + FX1^rightCode;
        elseif t.isFType() then
            -- TODO: Verifier code genere correct dans toutes situations.
            FX^leftCode := FX1^leftCode;
            FX^rightCode := FX1^rightCode;
        end
    end
end
} -- }}}

--
--
-- Acces champ pointeur.
FX -> arrow  ident #type1 FX #type2 #code ;
global
    -- Champ accede.
    c : VAR;

-- Verification du type racine.
#type1 { -- {{{
local
    p : PTR;
    pt : TYPE;
    s : STRUCT;
do
    if !(FX^typeLeft.isPointer()) then
        error(MCS_NOT_PTR, FX^typeLeft.name());
    else
        p := FX^typeLeft.toPointer();
        pt := p.ptype();
        if !(pt.isStruct()) then
            error(MCS_NOT_STRUCT, pt.name());
        else
            s := pt.toStruct();
            c := s.searchVar(ident^txt);
            if c = null then
                error(MCS_UNKNOWN_FIELD);
            else
                FX1^typeLeft := c.type();
            end
        end
    end
end
} -- }}}

-- Recuperation du type
#type2 { -- {{{
local
do
    FX^type := FX1^type;
end
} -- }}}

-- Generation de code acces champ pointeur.
#code { -- {{{
local
    hm : HelperMemoryInterface;
    hg : HelperGeneralInterface;
    hi : HelperIntInterface;
    -- Type du champ accede.
    t : TYPE;
    -- Adresse relative du champ accede.
    a : Address;
    -- Code de calcul de l'adresse absolue du champ accede.
    codeCommun : String;
do
    hm := FX^gen.getMemoryHelper();
    hg := FX^gen.getGeneralHelper();
    hi := FX^gen.getIntHelper();
    FX^endl := false;
    t := c.type();
    a := c.addr();
    -- Le code commun empile l'adresse du champ utilise.
    codeCommun := hg.generateConstante(a.val()) + hi.generateSum();
    if FX1^endl then
        -- Empilement de l'adresse de la variable (adresse du champ).
        FX^leftCode := codeCommun;
        -- Empilement de la valeur de la variable (valeur du champ).
        FX^rightCode := codeCommun + hm.generateDynamicRead(t.size());
    else
        if t.isStruct() then
            -- La differenciation effective se fera lors la generation du code de FX.
            -- Empilement de l'adresse de l'enregistrement puis de l'adresse du champ.
            FX^leftCode := codeCommun + FX1^leftCode;
            -- Empilement de l'adresse de l'enregistrement puis de la valeur du champ.
            FX^rightCode := codeCommun + FX1^rightCode;
        elseif t.isPointer() then
            -- La differenciation effective se fera lors la generation du code de FX.
            -- Empilement de l'adresse de la zone pointee, puis de l'adresse du champ.
            FX^leftCode := codeCommun + hm.generateDynamicRead(t.size()) + FX1^leftCode;
            -- Empilement de l'adresse de la zone pointee puis de la valeur du champ.
            FX^rightCode := codeCommun + hm.generateDynamicRead(t.size()) + FX1^rightCode;
        elseif t.isFType() then
            -- TODO: Verifier code genere correct dans toutes situations.
            FX^leftCode := FX1^leftCode;
            FX^rightCode := FX1^rightCode;
        end
    end
end
} -- }}}

--
--
-- Appel de sous-programme
FX -> #type1 paro ES parf FX #type2 #code ;

-- Verification du type racine.
#type1 { -- {{{
do
    if !(FX^typeLeft.isFType()) then
        error(MCS_NOT_FUNCTION, FX^typeLeft.name());
    else
        ES^typeF := FX^typeLeft.toFType();
        FX1^typeLeft := FX^typeLeft;
    end
end
} -- }}}

-- Recuperation du type.
#type2 { -- {{{
do
    FX^type := FX1^type;
end
} -- }}}

#code { -- {{{
local
    h : HelperFunctionInterface;
do
    h := FX^gen.getFunctionHelper();
    FX^endl := false;
    if FX^name = null then
        error(MCS_BAD_FCN_CALL);
    else
        FX^leftCode := h.generateCall(FX^name, FX^name, ES^code) + FX1^leftCode;
        FX^rightCode := h.generateCall(FX^name, FX^name, ES^code) + FX1^rightCode;
    end
end
} -- }}}

--
--
-- Appel de sous-programme sans arguments, aucune verification necessaire.
ES -> #code;

#code { -- {{{
local
do
    ES^code := "";
end
} -- }}}

--
--
-- Appel de sous-programme avec arguments.
ES -> E #type ESX #code;

-- Verification du type du parametre.
#type { -- {{{
local
    tParam : TYPE;
do
    tParam := ES^typeF.getParam(0);
    if E^type /= tParam then
        error(MCS_BAD_ARGUMENT, tParam.name(), E^type.name());
    else
        ESX^numParam := 1;
    end
end
} -- }}}

#code { -- {{{
local
do
    -- Concatenation du code des parametres.
    ES^code := E^code + ESX^code;
end
} -- }}}
--
--
-- Appel de sous-programme avec arguments : fin de liste.
ESX -> #code;

#code { -- {{{
local
do
    ESX^code := "";
end
} -- }}}
--
--
-- Appel de sous-programme avec arguments : suite.
ESX -> virg E #type ESX #code;

-- Verification du type du parametre.
#type { -- {{{
local
    tParam : TYPE;
do
    tParam := ESX^typeF.getParam(ESX^numParam);
    if E^type /= tParam then
        error(MCS_BAD_ARGUMENT, tParam.name(), E^type.name());
    else
        ESX1^numParam := ESX^numParam + 1;
    end
end
} -- }}}

#code { -- {{{
local
do
    -- Concatenation du code des parametres.
    ESX^code := E^code + ESX1^code;
end
} -- }}}

--
--
-- -- Inline asm
--
--

--
--
-- On peut avoir en entite de l'assembleur.
ENTITE -> asm #tds ASM #gen;

-- Utilisation de la tds au sein de l'asm.
#tds { -- {{{
do
    -- Transmission de la table courante pour que
    -- le code ASM puisse acceder aux variables de MC ou MCS.
    ASM^tds_asm := ENTITE^tds;
end
} -- }}}

-- Recuperation de l'assembleur.
#gen { -- {{{
do
    -- On recupere le code assembleur 'inline' dans : ASM^code_asm ;
    ENTITE^code := ASM^code_asm ;
end
} -- }}}

--
--
-- On peut avoir en instruction de l'assembleur.
INST -> asm #tds ASM #gen #type ;

-- Utilisation de la tds au sein de l'asm.
#tds { -- {{{
do
    -- A remplacer par la table courante pour que
    -- l'assembleur puisse acceder aux variables
    ASM^tds_asm := INST^tds;
end
} -- }}}

-- Utilisation de la tds au sein de l'asm.
#gen { -- {{{
do
    -- ASM^code_asm contient le code assembleur inline
    -- dans lequel les noms de variables ont ete remplaces
    -- par leurs adresses.
    INST^code := ASM^code_asm;
end
} -- }}}

-- Evaluation du type de l'instruction
#type { -- {{{
do
    -- TODO: Verifier la validite de null pour une instruction ASM.
    INST^type := null;
end
} -- }}}

--
--
----------------- CS extension --------------------
-- Decommenter les regles suivantes pour l'extension CS
-------------------------------------------------
--
--

--
--
-- Constante booleenne.
TYPE -> bool #type ;

-- Les types de base sont deja presents dans la TDS.
#type { -- {{{
local
do
    TYPE^type := TYPE^tds.searchType("bool", true);
end
} -- }}}

--
--
---- Namespaces.
--
--

--
--
---- Definit un namespace (et son contenu).
ENTITE -> namespace identc #type aco ENTITES acf #code ;

-- Enregistre le namespace dans la tds et
-- cree les ressources necessaires a son utilisation.
#type { -- {{{
do
    ENTITES^tds := ENTITE^tds.createNamespace(identc^txt);
end
} -- }}}

-- Transmission du code.
#code { -- {{{
local
    h : HelperGeneralInterface;
do
    h := ENTITE^gen.getGeneralHelper();
    ENTITE^code := h.generateComment("--- Namespace " + identc^txt + " ---") + ENTITES^code + h.generateComment("--- Fin definition namespace " + identc^txt + " ---");
end
} -- }}}

--
--
---- Donne l'acces au contenu du 'namespace'.
---- Definit le namespace en cours d'utilisation.
ENTITE -> using identc #type IDC pv #code ;

-- Redefinit le namespace en cours d'utilisation.
#type { -- {{{
do
    -- use(String namespace, boolean root)
    -- root est vrai pour l'ident directement apres le using,
    -- false pour les idents suivants (separes par des points -> IDC).
    ENTITE^tds.use(identc^txt, true);
end
} -- }}}

-- Generation de code pour using (rien).
#code { -- {{{
do
    ENTITE^code := "";
end
} -- }}}

--
--
---- Sous partie d'un nom (namespace/classe).
IDC -> ;

--
--
---- Sous partie d'un nom (namespace/classe).
IDC -> pt identc #type IDC ;

-- Redefinit le namespace en cours d'utilisation.
#type { -- {{{
do
    -- use(String namespace, boolean root)
    -- root est vrai pour l'ident directement apres le using,
    -- false pour les idents suivants (separes par des points -> IDC).
    IDC^tds.use(identc^txt, false);
end
} -- }}}

--
--
---- Definition d'une classe (peut etre en dehors d'un namespace).
ENTITE ->
    ACCES class identc #create HERITAGE aco #begin DEFS acf #cloture #code;
global
    newClass: CLASS;

-- Création de la classe
#create { -- {{{
local
    t: TYPE;
do
    t := ENTITE^tds.searchType(identc^txt);
    if t /= null then
       error(MCS_TAE, identc^txt);
    else
        newClass := new CLASS(ENTITE^tds, identc^txt);
        ENTITE^tds.putType(newClass.name(), newClass);
    end
end
} -- }}}

-- Passage des paramètres requis à DEFS pour la génération
#begin { -- {{{
do
    DEFS^classHere := newClass;
end
} -- }}}

#cloture { -- {{{
do
    newClass.close();
    -- Bloque la lecture d'attributs privés en dehors de la classe.
end
} -- }}}

-- Generation de code pour la creation d'une classe.
#code { -- {{{
do
    -- TODO: Creation de la classe.
    ENTITE^code := "";
end
} -- }}}

--
--
---- Type d'acces aux elements d'une classe.
--
--

-- Mode publique.
ACCES -> public #value ;

-- C'est un acces publique.
#value { -- {{{
do
    ACCES^isPub := true;
end
} -- }}}

-- Mode prive.
ACCES -> private #value ;

-- C'est un acces prive.
#value { -- {{{
do
    ACCES^isPub := false;
end
} -- }}}

-- Mode par defaut (public ?).
ACCES -> #value ;

-- C'est un acces publique.
#value { -- {{{
do
    ACCES^isPub := true;
end
} -- }}}

--
--
---- Heritage.
--
--

-- Sans heritage.
HERITAGE -> ;

-- Avec heritage.
HERITAGE -> dpts identc IDC ;

--
--
---- Membres d'une classe.
--
--

--
--
---- Fin de definition d'une classe.
DEFS -> ;

--
--
---- Liste des membres d'une classe.
DEFS -> ACCES DEF#def DEFS ;

#def{ --{{{
local
do

end
} --}}}

--
--
---- Methode/Attribut d'une classe.
DEF  -> TYPE ident#prerecord DECL #record;

#prerecord { -- {{{
local
    v : VAR ;
do
    -- Verifier qu'aucune fonction/variable du meme nom n'est pas deja definie
    -- localement.
    v := DEF^classHere.searchVar(ident^txt, false);
    if v /= null then
        error(MCS_DAE, ident^txt,DEF^classHere.name());
    else
        -- Propagation du type declare.
        DECL^typeLeft := TYPE^type;
        -- Propagation du nom de l'ident de gauche.
        DECL^name := ident^txt;
    end
end
} -- }}}

-- Enregistrement de la declaration dans la table des symboles.
#record { -- {{{
local
    t : TYPE;
do
    -- Calcul du type de la variable/fonction.
    if DECL^varF = null then
        -- Enregistrement effectif de la variable dans la tds.
        DEF^classHere.putVar(ident^txt, TYPE^type);
    else
        t := DECL^varF.type();
        -- Enregistrement du type de la fonction dans la table des types.
        DEF^classHere.putType(t.name(), t);
        -- Enregistrement effectif de la fonction dans la tds.
        DEF^classHere.putVar(ident^txt, DECL^varF);
    end
end
} -- }}}


--
--
---- Constructeur de classe.
DEF  -> identc paro PARFS parf BASE BLOC;

--
--
---- Appel eventuel au constructeur de la classe parente.
BASE -> ;
BASE -> dpts base paro ES parf  ;

--
--
---- Mode de passage pour les fonctions et methodes : rien : D, ref : D/R, out : R.
PARF -> MODE TYPE ident ;

--
--
---- Mode ref : Donnee/Resultat.
MODE -> ref ;

--
--
---- Mode out : Resultat.
MODE -> out ;

--
--
---- Constante booleenne.
F -> true #type #code ;

-- Recuperation du type pour constante booleenne.
#type { -- {{{
local
do
    F^type := F^tds.searchType("bool", true);
end
} -- }}}

-- Generation de code pour une constante booleenne.
#code { -- {{{
local
    h : HelperGeneralInterface;
do
    h := F^gen.getGeneralHelper();
    -- Une constante est necessairement une rightValue.
    -- TODO: Declencher une erreur de compilation si la constante est utilisee en tant que leftValue.
    F^leftCode := "";
    F^rightCode := h.generateConstante("1");
end
} -- }}}

--
--
---- Constante booleenne.
F -> false #type #code ;

-- Recuperation du type pour constante booleenne.
#type { -- {{{
local
do
    F^type := F^tds.searchType("bool", true);
end
} -- }}}

-- Generation de code pour une constante booleenne.
#code { -- {{{
local
    h : HelperGeneralInterface;
do
    h := F^gen.getGeneralHelper();
    -- Une constante est necessairement une rightValue.
    -- TODO: Declencher une erreur de compilation si la constante est utilisee en tant que leftValue.
    F^leftCode := "";
    F^rightCode := h.generateConstante("0");
end
} -- }}}

--
--
---- Pointeur this.
F -> this FX;

--
--
---- Pointeur base (<=> super en java ?).
F -> base FX;

--
--
---- Constante null (en minuscule -> pour les objets ?).
F -> null2;

--
--
---- Construction d'un objet.
F -> new identc IDC paro ES parf ;

end
