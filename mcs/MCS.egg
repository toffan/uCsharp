-----------------------------------------------------
-- Grammaires de MC  et MCS                        --
-----------------------------------------------------

--
-- Options
option auto = true;
option version = 0.0.1;
option k=2;

--
-- Attributes

-- Le fichier source
inh source : MCSSourceFile for PROGRAMME;

-- La machine cible pour la generation de code.
-- inh machine : IMachine for
--        ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
--        PARFS, PARF, PARFSX, ES, ESX,
--        E, AFFX, A, AX, R, RX, T, TX, F, FX
--      -- Decommenter la ligne suivante pour MCS
--      , BASE, DEFS, DEF
--      -- Fin extension MCS
--        ;

-- Ces attributs permettent de recuperer les instructions du code ASM inline.
syn code_asm : STRING for ASM;

-- La TDS courante.
inh tds_asm : TDS for ASM;

-- Custom attributes.
inh tds : TDS for
        PROGRAMME, ENTITES, ENTITE, DECL,
        FONCTION, PARF, PARFS, PARFSX, BLOC,
        INSTS, INST, TYPE, STYPE, PTRS,
        CHAMPS, CHAMP,
        E, A, AFFX, R, RX, AX, T, TX, F, FX, SIX,
        ES, ESX ;

syn type : TYPE for
        TYPE,
        BLOC, INSTS, INST, E, STYPE, PTRS,
        A, AFFX, R, AX, T, TX, F, FX, SIX, RX ;

-- Typage d'un enregistrement.
inh typeCHP : STRUCT for CHAMPS, CHAMP;

-- Type a gauche d'une declaration.
inh typeLeft : TYPE for DECL, PTRS, FX;

-- Typage appel de sous-programme.
inh typeF : FTYPE for ES, ESX ;
inh numParam : Integer for ESX;

-- Typage declaration de fonction.
syn varF : FCT for DECL ;
inh fct : FCT for FONCTION, PARFS, PARFSX, PARF,
        BLOC, INSTS, INST, SIX ;

-- Le generateur de code.
inh gen : GeneratorItf for
        PROGRAMME, ENTITES, ENTITE, DECL,
        FONCTION, PARF, PARFS, PARFSX, BLOC,
        INSTS, INST, TYPE, STYPE, PTRS,
        CHAMPS, CHAMP,
        E, A, AFFX, R, RX, AX, T, TX, F, FX, SIX,
        OPREL, OPADD, OPMUL,
        ES, ESX ;

-- Le code genere.
syn code : String for
         ENTITES, ENTITE, DECL, FONCTION,
         BLOC, INSTS, INST, AFFX, E, SIX,
         AX, OPREL, RX, OPADD, TX, OPMUL, FX ;

-- Nom de l'ident a gauche d'une declaration.
inh name : String for DECL;

-- Code generant une adresse.
syn leftCode : String for A, R, T, F ;
-- Code generant une valeur.
syn rightCode : String for A, R, T, F ;

--le code généré pour chaque parametre d'une fonction
syn codeList : ArrayList<String> for ES, ESX;

-- Permet de savoir si les parametres d'une operation doivent etre au prealable convertis en booleens.
syn toBool : Boolean for OPADD, OPMUL ;

-- Terminaux
space separateur is    "[\r\n\t ]+";
space comm is    "\/\/[^\n]*\n";
sugar paro is    "\(";
sugar parf is    "\)";
sugar aco is    "\{";
sugar acf is    "\}";
sugar virg is    ",";
sugar pt is "\.";
sugar pv is    "\;";
sugar affect is    "=";
sugar si is    "if";
sugar sinon is    "else";
sugar void is    "void";
sugar asm is    "asm";
sugar int is    "int";
sugar char is    "char";
sugar struct is "struct";
sugar typedef is "typedef";

-- Decommenter pour MCS
--sugar ref is "ref" ;
--sugar out is "out";
--sugar namespace is "namespace";
--sugar using is "using";
--sugar class is "class";
--sugar public is "public" ;
--sugar private is "private";
--sugar dpts is "\:";
--sugar bool is "bool";
--sugar true is "true";
--sugar false is "false";
--sugar this is "this";
--sugar new is "new" ;
--sugar null2 is "null";
--sugar base is "base" ;

sugar retour is    "return";
sugar arrow is "\-\>";
sugar null is    "NULL";
sugar inf is    "\<";
sugar infeg is    "\<=";
sugar sup is    "\>";
sugar supeg is    "\>=";
sugar eg is    "==";
sugar neg is    "\!=";
sugar plus is    "\+";
sugar moins is    "\-";
sugar ou is    "\|\|";
sugar mult is    "\*";
sugar div is    "\/";
sugar mod is    "\%" ;
sugar et is    "\&\&";
sugar non is    "\!";
term entier is    "[0-9]+";
term caractere is    "\'[^\']\'";
term chaine is    "\"[^\"]*\"";
term ident is    "[a-z][_0-9A-Za-z]*";
term identc is    "[A-Z][_0-9A-Za-z]*";

-- Pour les instructions en assembleur TAM 'inline'.
compil ASM;

--
--
-- Regle de production, point d'entree.
PROGRAMME -> #init ENTITES #gen;
global
    -- Transmission de la machine cible (choisie par l'option -m au lancement)
    --machine : IMachine;
    gen: GeneratorItf;

-- Initialise le compilateur.
#init {
local
    string : TYPE;
    tds : TDS;
do
--    machine := PROGRAMME^source.getMachine();
    gen := new TamGenerator(PROGRAMME^source.getFileName()); -- On reviendra sur le choix de la machine plus tard.
    if gen = null then
        error(NO_MACH, PROGRAMME^source.getMachName());
    else
        ENTITES^gen := gen;
    end

    tds := new TDS();
    -- Ajouter a la TDS les types natifs.
    tds.putType("void", new TYPE("void", 0));
    tds.putType("int", new TYPE("int", 1));
    tds.putType("char", new TYPE("char", 1));
    string := new PTR(tds.searchType("char", true));
    tds.putType(string.name(), string);

    ENTITES^tds := tds;
end
}

-- Ecrit le code dans un fichier.
#gen {
local
do
    gen.generateFile(";" + gen.getFileName() + "\n" + ENTITES^code + "; EOF\n");
end
}

--
--
-- -- Entites
--
--

ENTITES -> #code;

-- Fin de liste d'instructions, plus de code a generer.
#code {
local
do
	ENTITES^code := "";
end
}

ENTITES -> ENTITE ENTITES #code;

-- Generetion du code d'une sequence d'entites.
#code {
local
do
	ENTITES^code := ENTITE^code + ENTITES1^code;
end
}

--
--
-- Definition d'un nom de type (commence par une majuscule).
ENTITE -> typedef TYPE identc pv #record #code;

-- Enregistrement du nouveau type dans la table des symboles.
#record {
local
    t : TYPE ;
do
    -- Verifier qu'aucun type du meme nom n'est pas deja defini localement.
    t := ENTITE^tds.searchType(identc^txt, false);
    if t /= null then
        error(MCS_TAE, identc^txt);
    else
        -- Enregistrement effectif du type.
        if TYPE^type = null then
            error(MCS_TYPE_NULL, identc^txt);
        else
            ENTITE^tds.putType(identc^txt, TYPE^type);
        end
    end
end
}

#code {
local
do
	ENTITE^code := "; typedef de "+identc^txt+"\n";
end
}

--
--
-- Definition d'une variable globale ou d'une fonction.
-- (Commence par une minuscule)
ENTITE -> TYPE ident #prerecord DECL #record #code ;

-- Verification de la non existence de l'ident dans la tds locale.
#prerecord {
local
    v : VAR ;
do
    -- Verifier qu'aucune fonction/variable du meme nom n'est pas deja definie
    -- localement.
    v := ENTITE^tds.searchVar(ident^txt, false);
    if v /= null then
        error(MCS_DAE, ident^txt);
    else
        -- Propagation du type declare.
        DECL^typeLeft := TYPE^type;
        -- Propagation du nom de l'ident de gauche.
        DECL^name := ident^txt;
    end
end
}

-- Enregistrement de la declaration dans la table des symboles.
#record {
local
    t : TYPE;
do
    -- Calcul du type de la variable/fonction.
    if DECL^varF = null then
        -- Enregistrement effectif de la variable dans la tds.
        ENTITE^tds.putVar(ident^txt, TYPE^type);
    else
        t := DECL^varF.type();
        -- Enregistrement du type de la fonction dans la table des types.
        ENTITE^tds.putType(t.name(), t);
        -- Enregistrement effectif de la fonction dans la tds.
        ENTITE^tds.putVar(ident^txt, DECL^varF);
    end
end
}

-- Recuperation du code de la declaration.
#code {
do
    ENTITE^code := DECL^code;
end
}

--
--
-- -- Declaration
--
--

--
--
-- Fin de la declaration (variable).
DECL -> #type #code pv ;

-- Pas de fonction sous-jacente.
#type {
do
    DECL^varF := null;
end
}

-- Generation du code pour une declaration de variable.
#code {
local
    h : HelperMemoryInterface;
do
    h := DECL^gen.getMemoryHelper();
    DECL^code := h.generateReserve(DECL^typeLeft.size());
end
}

--
--
-- Fin de la declaration (fonction).
DECL -> #type FONCTION #code ;

-- Creation du type de la fonction et de la VAR correspondante.
#type {
local
    f : FCT;
    t : FTYPE;
do
    -- Creation du type a partir du type de retour de la fonction.
    t := new FTYPE(DECL^typeLeft);
    -- Creation de la VAR representant la fonction.
    f := new FCT(t, DECL^tds, DECL^name);
    -- Propagation de la VAR a DECL pour enregistrement dans la TDS (de la VAR ET du type associe).
    DECL^varF := f;
    -- Transmission de la VAR a FONCTION pour reellement generer la fonction et son type
    FONCTION^fct := f;
end
}

-- Generation du code pour une declaration de fonction.
#code {
local
    h : HelperFunctionInterface;
do
    h := DECL^gen.getFunctionHelper();
    DECL^code := h.generateFunction(DECL^name, "_" + DECL^name, FONCTION^code);
end
}

--
--
-- -- Fonction
--
--

--
--
-- Debut de la premiere ligne d'une fonction.
FONCTION -> paro PARFS parf #type BLOC #code ;

-- Transmission de la TDS interne de la fonction au corps de fonction.
#type {
local
do
    BLOC^tds := FONCTION^fct.tds();
end
}

-- Recuperation du code du corps de la fonction
-- Insertion d'un return artificiel au cas ou il n'y en aurait pas.
#code {
local
    h : HelperFunctionInterface;
    tFct : FTYPE;
    tReturn : TYPE;
do
    h := FONCTION^gen.getFunctionHelper();
    tFct := FONCTION^fct.type();
    tReturn := tFct.retType();
    FONCTION^code := BLOC^code + "; return artificiel pour " + FONCTION^fct.name() + "\n" + h.generateReturn(tFct.sizeParams(), 0, "");
end
}

--
--
-- Fonction sans aucun parametres.
PARFS -> ;

--
--
-- Premier parametre la fonction.
PARFS -> PARF PARFSX ;
-- Transmission implicite de PARFS^fct.

--
--
-- Fin de la liste de parametres.
PARFSX -> ;

--
--
-- Fonction : parametre supplémentaire.
PARFSX -> virg PARF PARFSX ;
-- Transmission implicite de PARFSX^fct.

--
--
-- Evaluation d'un parametre de fonction (typage et enregistrement).
PARF -> TYPE ident #type #record ;

-- Enregistrement du type du parametre de la fonction.
#type {
local
    t : FTYPE;
do
    t := PARF^fct.type();
    -- Ajout du type du parametre dans le type de la fonction.
    -- Attention : a faire avant d'enregistrer le parametre dans la liste des parametres !
    t.putParam(TYPE^type);
end
}

-- Enregistrement du parametre dans la liste de parametres de la fonction.
#record {
local
    f : FCT;
do
    f := PARF^fct;
    -- Verifier qu'aucun parametre du meme nom n'est pas deja defini.
    if f.contains(ident^txt) then
        error(MCS_PAE, ident^txt);
    else
        -- Ajout du parametre dans la liste de parametres de la fonction.
        f.putParam(ident^txt);
    end
end
}

--
--
-- -- Types
--
--

--
--
-- Structure d'un type, pointeur ou non.
TYPE -> STYPE #type1 PTRS #type2 ;

-- Propagation du premier type.
#type1 {
local
do
    PTRS^typeLeft := STYPE^type;
end
}

-- Propagation du second type.
#type2 {
local
do
    TYPE^type := PTRS^type;
end
}

--
--
-- Pointeur, fin de la liste d'etoile.
PTRS -> #type ;

-- Propagation du type du pointeur.
#type {
local
do
    PTRS^type := PTRS^typeLeft;
end
}

--
--
-- Pointeur, une etoile de plus dans la liste d'etoiles.
PTRS -> mult PTRS #type ;

-- Ajout du type a la table des symboles.
#type {
local
    t : PTR;
    o : TYPE;
do
    -- Instanciation d'un type pointeur.
    t := new PTR(PTRS1^type);

    -- Recherche du type pointeur dans la table des types.
    o := PTRS^tds.searchType(t.name(), true);

    -- Propagation du type.
    if o /= null then
        -- L'instance precedemment creee.
        PTRS^type := o;
    else
        -- L'instance nouvellement creee.
        PTRS^type := t;
        -- Ajout du type dans la TDS.
        PTRS^tds.putType(t.name(), t);
    end
end
}

--
--
-- Types de base (void)
STYPE-> void #type ;

-- Les types de base sont deja presents dans la TDS.
#type {
local
do
    STYPE^type := STYPE^tds.searchType("void", true);
end
}

--
--
-- Types de base (int)
STYPE-> int #type ;

-- Les types de base sont deja presents dans la TDS.
#type {
local
do
    STYPE^type := STYPE^tds.searchType("int", true);
end
}

--
--
-- Types de base (char)
STYPE-> char #type ;

-- Les types de base sont deja presents dans la TDS.
#type {
local
do
    STYPE^type := STYPE^tds.searchType("char", true);
end
}

--
--
-- Identificateur d'un type (pour les types nommes par le codeur).
STYPE -> identc #type ;

-- Resolution du type nomme dans la TDS.
#type {
local
    t : TYPE;
do
    t := STYPE^tds.searchType(identc^txt, true);
    if t = null then
        error(MCS_TUN, identc^txt);
    else
        STYPE^type := t;
    end
end
}

--
--
-- Type d'une struct.
STYPE -> #type struct aco CHAMPS acf ;

-- Creation du type struct initial (vide).
#type {
local
    s : STRUCT;
do
    s := new STRUCT();
    CHAMPS^typeCHP := s;
    STYPE^type := s;
end
}

--
--
-- Fin de l'evaluation du type struct.
CHAMPS -> ;

--
--
-- Evaluation du type struct, liste de champ.
CHAMPS -> CHAMP CHAMPS ;

--
--
-- Decomposition du contenu d'un champ.
CHAMP -> TYPE ident pv #type ;

-- Enregistrement du type d'un champ dans la TPS de la struct.
#type {
local
    v : VAR ;
do
    -- Verifier qu'aucune fonction/variable du meme nom n'est pas deja definie
    -- localement dans la struct.
    v := CHAMP^typeCHP.searchVar(ident^txt);
    if v /= null then
        error(MCS_DAE, ident^txt);
    else
        -- Enregistrement effectif de la declaration.
        CHAMP^typeCHP.putVar(ident^txt, TYPE^type);
    end
end
}

--
--
-- -- Bloc de code
--
--

--
--
-- Delimitation d'un bloc de code.
BLOC -> aco INSTS acf #type #code ;

-- Le type propage est non-null si le bloc contient une instruction " return ".
#type {
local
do
    BLOC^type := INSTS^type;
end
}

#code {
do
    BLOC^code := INSTS^code;
end
}

--
--
-- Instruction vide, effet de bord.
INSTS -> #type #code ;

-- Un effet de bord ne retourne rien, type null.
#type {
local
do
    INSTS^type := null;
end
}

-- Pas de code genere.
#code {
do
    INSTS^code := "";
end
}

--
--
-- Ajout d'une instruction dans le bloc.
INSTS -> INST INSTS #type #code ;

-- Le type d'une instruction INST (differente d'une expression E) est soit :
--    - null (effet de bord).
--    - Resultat d'un return.
#type {
local
do
    -- Le type d'une liste d'instructions INSTS est le type de la premiere INST
    --     de type non-null (i.e. du premier return de la sequence).
    if INST^type /= null then
        INSTS^type := INST^type;
    else
        INSTS^type := INSTS1^type;
    end
end
}

-- Concatenation du code genere pour les differentes instructions.
#code {
do
    INSTS^code := INST^code + INSTS1^code;
end
}

--
--
-- Declaration d'une variable locale, avec ou sans initialisation.
INST -> TYPE ident #record AFFX pv #type #code ;

-- Enregistrement de la variable dans la TDS du bloc.
#record {
local
    v : VAR;
do
    v := INST^tds.searchVar(ident^txt, false);
    if v /= null then
        error(MCS_DAE);
    else
        INST^tds.putVar(ident^txt, TYPE^type);
    end
end
}

-- Typage de l'instruction et verification du type de l'affectation.
#type {
local
do
    -- Une declaration ou une affectation est un effet de bord, pas de type.
    INST^type := null;

    -- Verification du type de l'affectation.
    if AFFX^type /= null && AFFX^type /= TYPE^type then
        error(MCS_BAD_TYPE_2, TYPE^type.name(), AFFX^type.name(), ident^txt);
    end
end
}

-- Recuperation du code genere.
#code {
local
    h : HelperMemoryInterface;
do
    h := INST^gen.getMemoryHelper();
    if AFFX^type = null then
        -- Generation du code pour une declaration sans initialisation.
        INST^code := h.generateReserve(TYPE^type.size());
    else
        -- Generation du code pour une declaration avec initialisation (recuperation de la rightValue).
        INST^code := AFFX^code;
    end
end
}

--
--
-- Instruction " expression " (affectation et appel de procedure).
INST -> E pv #type #code ;

-- Une expression seule est un effet de bord, pas de type.
#type {
local
do
    INST^type := null;
end
}

-- Recuperation du code genere.
#code {
do
    INST^code := E^code;
end
}

--
--
-- Un nouveau bloc est insere en instruction.
INST -> BLOC #type #code ;

-- Un nouveau bloc est insere en instruction, si il est dote d'un type de
-- retour, il contient un " return ", et son type se propage
#type {
local
do
    INST^type := BLOC^type;
end
}

-- Recuperation du code genere.
#code {
do
    INST^code := BLOC^code;
end
}

--
--
-- Bloc conditionnel.
INST -> si paro E parf BLOC SIX #type #code ;

-- Le type du bloc conditionnel correspond au type de retour commun.
#type {
local
do
    -- Une expression conditionnelle est de type de retour entier.
    if E^type /= INST^tds.searchType("int", true) then
        -- TODO: Completer l'erreur avec du texte representant l'expression.
        error(MCS_NOT_BOOLEAN, E^type.name());
    else
        if BLOC^type /= null then
            if SIX^type /= null then
                if BLOC^type /= SIX^type then
                    -- Les deux bloc renvoient des types differents, erreur.
                    error(MCS_BAD_TYPE, BLOC^type.name(), SIX^type.name());
                else
                    -- Les deux blocs existent et renvoient le meme type.
                    INST^type := BLOC^type;
                end
            else
                -- Pas de deuxieme bloc, ou un bloc d'effets de bord.
                INST^type := BLOC^type;
            end
        else
            -- Le premier bloc ne contient que des effets de bord.
            -- (On utilise le type de retour de SIX)
            INST^type := SIX^type;
        end
    end
end
}

-- Generation du code pour le if.
#code {
local
    h : HelperGeneralInterface;
do
    h := INST^gen.getGeneralHelper();
    INST^code := h.generateIf(E^code, BLOC^code, SIX^code);
end
}

--
--
-- Bloc sinon.
SIX -> sinon BLOC #type #code ;

-- Propagation du type.
#type {
local
do
    SIX^type := BLOC^type;
end
}

-- Recuperation du code genere.
#code {
do
    SIX^code := BLOC^code;
end
}

--
--
-- Pas de bloc suivant dans la conditionnelle.
SIX -> #type #code ;

-- Pas de bloc, considere comme un effet de bord.
#type {
local
do
    SIX^type := null;
end
}

-- Recuperation du code genere.
#code {
do
    SIX^code := "";
end
}

--
--
-- L'instruction retourne un type, un " return de fonction ".
INST -> retour E pv #type #code ;
#type {
local
do
    -- Instruction return : on transfere le type de l'expression renvoyee.
    INST^type := E^type;
end
}

#code {
local
    h : HelperFunctionInterface;
    tFct : FTYPE;
do
    h := INST^gen.getFunctionHelper();
    tFct := INST^fct.type();
    INST^code := E^code + "; return explicite pour " + INST^fct.name() + "\n" + h.generateReturn(tFct.sizeParams(), E^type.size(), "");
end
}

--
--
-- -- Expressions
--
--

-------------------------------------------------------------------------
-- Lexique                                                              -
-------------------------------------------------------------------------
-- E = Expression (y compris l'affectation)                             -
-- A = Expression figurant dans une affectation                         -
-- R = Expression figurant dans une expresion relationnelle             -
-- T = Expression figurant dans une expression additive (TERME)         -
-- F = Expression figurant dans une expression multiplicative (FACTEUR) -
-------------------------------------------------------------------------

--
--
-- Expression qui affecte.
E -> A AFFX #type #code ;

-- Verification du type des affectations.
#type {
local
do
    if AFFX^type /= null && AFFX^type /= A^type then
        error(MCS_BAD_TYPE_2_BIS, A^type.name(), AFFX^type.name());
    else
        E^type := A^type;
    end
end
}

#code {
local
    h : HelperMemoryInterface;
do
    h := E^gen.getMemoryHelper();
    if AFFX^type /= null then
        -- Affectation
        -- Duplication de AFFX^code sur la pile pour que le resultat d'une affectation soit la valeur affectee.
        E^code := AFFX^code + h.generateDuplicate(AFFX^type.size()) + A^leftCode + h.generateDynamicWrite(AFFX^type.size());
    else
        -- Recuperation simple de la valeur d'une expression (de meme que pour une rightValue).
        E^code := A^rightCode;
    end
end
}

--
--
-- Affectation
AFFX -> affect A #type #code ;

-- Verification du type des affectations (suite).
#type {
local
do
    AFFX^type := A^type;
end
}

-- Generation du code pour une declaration avec initialisation : on utilise le code genere pour A.
#code {
local
do
    AFFX^code := A^rightCode;
end
}

--
--
-- Fin d'une affectation.
AFFX -> #type #code ;

-- Verification du type des affectations (fin).
#type {
local
do
    AFFX^type := null;
end
}

-- Generation du code pour une absence de rightValue.
#code {
do
    AFFX^code := "";
end
}

--
--
-- Relation, moins prioritaire que A.
A -> R AX #type #code;

-- Verification du type d'une relation.
#type {
local
do
    if AX^type /= null then
        if AX^type /= R^type then
            error(MCS_BAD_TYPE_3, R^type.name(), AX^type.name());
        else
            -- Condition : type int ou bool selon la version.
            A^type := A^tds.searchType("int", true);
        end
    else
        -- Pas de comparaison, utilisation du type de R.
        A^type := R^type;
    end
end
}

-- Generation du code d'une relation.
#code {
local
do
    if AX^type /= null & AX^type = R^type then
        -- A est une condition booleenne donc forcement une rightValue...
        A^leftCode := "";
        -- La comparaison est faite dans le code de AX.
        A^rightCode := R^rightCode + AX^code;
    else
        -- On ne prend pas en compte ici l'erreur de type ayant deja ete traitee au dessus.
        -- On recupere les deux types de code generes (pas de comparaison a ce niveau).
        A^leftCode := R^leftCode;
        A^rightCode := R^rightCode;
    end
end
}

--
--
-- Operateur relationnel.
AX -> OPREL R #type #code ;

-- Verification du type d'une relation (suite).
#type {
local
do
    -- Les operateurs relationels de base utilisent des entiers.
    if R^type /= AX^tds.searchType("int", true) then
        error(MCS_BAD_TYPE_3, "int", R^type.name());
    else
        AX^type := R^type;
    end
end
}

-- Generation de code pour une relation (suite).
#code {
do
    -- La comparaison a lieu ici.
    -- OPREL^code contient l'appel a l'operateur de comparaison.
    AX^code := R^rightCode + OPREL^code;
end
}

--
--
-- Fin de la relation.
AX -> #type #code ;

-- Verification du type d'une relation (fin).
#type {
local
do
    AX^type := null;
end
}

-- Pas de code genere.
#code {
do
    AX^code := "";
end
}

--
--
-- Operateurs relationnels.
OPREL -> inf #code ;

-- Generation de code : appel de la subroutine correspondante.
#code {
local
    h : HelperIntInterface;
do
    h := OPREL^gen.getIntHelper();
    OPREL^code := h.generateLss();
end
}

OPREL -> sup #code ;

-- Generation de code : appel de la subroutine correspondante.
#code {
local
    h : HelperIntInterface;
do
    h := OPREL^gen.getIntHelper();
    OPREL^code := h.generateGtr();
end
}

OPREL -> infeg #code ;

-- Generation de code : appel de la subroutine correspondante.
#code {
local
    h : HelperIntInterface;
do
    h := OPREL^gen.getIntHelper();
    OPREL^code := h.generateLeq();
end
}

OPREL -> supeg #code ;

-- Generation de code : appel de la subroutine correspondante.
#code {
local
    h : HelperIntInterface;
do
    h := OPREL^gen.getIntHelper();
    OPREL^code := h.generateGeq();
end
}

OPREL -> eg #code ;

-- Generation de code : appel de la subroutine correspondante.
#code {
local
    h : HelperIntInterface;
do
    h := OPREL^gen.getIntHelper();
    OPREL^code := h.generateEq();
end
}

OPREL -> neg #code ;

-- Generation de code : appel de la subroutine correspondante.
#code {
local
    h : HelperIntInterface;
do
    h := OPREL^gen.getIntHelper();
    OPREL^code := h.generateNeq();
end
}

--
--
-- Terme.
R -> T RX #type #code;

-- Verification du type d'une operation additive.
#type {
local
do
    if RX^type /= null && RX^type /= T^type then
        error(MCS_BAD_TYPE_4, T^type.name(), RX^type.name());
    else
        R^type := T^type;
    end
end
}

-- Generation du code d'une operation additive.
#code {
local
do
    if RX^type /= null & RX^type = T^type then
        -- R contient une addition donc est forcement une rightValue...
        R^leftCode := "";
        -- L'addition est faite dans le code de RX.
        R^rightCode := T^rightCode + RX^code;
    else
        -- On ne prend pas en compte ici l'erreur de type ayant deja ete traitee au dessus.
        -- On recupere les deux types de code generes (pas d'addition a ce niveau).
        R^leftCode := T^leftCode;
        R^rightCode := T^rightCode;
    end
end
}

--
--
-- Additions ...
RX -> OPADD T RX #type #code;

-- Verification du type d'une operation additive (suite).
#type {
local
do
    if RX1^type /= null && RX1^type /= T^type then
        error(MCS_BAD_TYPE_4, T^type.name(), RX1^type.name());
    else
        -- Les operateurs additifs de base utilisent des entiers.
        if T^type /= RX^tds.searchType("int", true) then
            error(MCS_BAD_TYPE_4, "int", T^type.name());
        else
            RX^type := T^type;
        end
    end
end
}

-- Generation du code pour les operations additives (suite).
#code {
local
    h : HelperIntInterface;
do
    h := RX^gen.getIntHelper();
    -- L'operation additive a lieu ici.
    -- OPADD^code contient l'appel a l'operateur.
    if OPADD^toBool then
        -- Si l'operateur utilise necessite une conversion prealable en booleen.
        RX^code := h.generateIntToBool() + T^rightCode + h.generateIntToBool() + OPADD^code + RX1^code;
    else
        RX^code := T^rightCode + OPADD^code + RX1^code;
    end
end
}

--
--
-- Fin d'une addition.
RX -> #type #code;

-- Verification du type d'une operation additive (fin).
#type {
local
do
    RX^type := null;
end
}

-- Pas de code genere.
#code {
do
	RX^code := "";
end
}

--
--
-- Operateurs additifs.

OPADD -> plus #code ;

-- Generation de code : appel de la subroutine correspondante.
#code {
local
    h : HelperIntInterface;
do
    h := OPADD^gen.getIntHelper();
    OPADD^code := h.generateSum();
    OPADD^toBool := false;
end
}

OPADD -> moins #code ;

-- Generation de code : appel de la subroutine correspondante.
#code {
local
    h : HelperIntInterface;
do
    h := OPADD^gen.getIntHelper();
    OPADD^code := h.generateSub();
    OPADD^toBool := false;
end
}

OPADD -> ou #code ;

-- Generation de code : appel de la subroutine correspondante.
#code {
local
    h : HelperBoolInterface;
do
    h := OPADD^gen.getBoolHelper();
    OPADD^code := h.generateOr();
    OPADD^toBool := true;
end
}

--
--
-- Multiplication, ...
T -> F TX #type #code;

-- Verification du type d'une operation multiplicative.
#type {
local
do
    if TX^type /= null && TX^type /= F^type then
        error(MCS_BAD_TYPE_5, F^type.name(), TX^type.name());
    else
        T^type := F^type;
    end
end
}

-- Generation du code d'une operation multiplicative.
#code {
local
do
    if TX^type /= null & TX^type = F^type then
        -- T contient une multiplication donc est forcement une rightValue...
        T^leftCode := "";
        -- La multiplication est faite dans le code de TX.
        T^rightCode := F^rightCode + TX^code;
    else
        -- On ne prend pas en compte ici l'erreur de type ayant deja ete traitee au dessus.
        -- On recupere les deux types de code generes (pas de multiplication).
        T^leftCode := F^leftCode;
        T^rightCode := F^rightCode;
    end
end
}

--
--
-- Suite de la multiplication.
TX -> OPMUL F TX #type #code;

-- Verification du type d'une operation multiplicative (suite).
#type {
local
do
    if TX1^type /= null && TX1^type /= F^type then
        error(MCS_BAD_TYPE_5, F^type.name(), TX1^type.name());
    else
        -- Les operateurs multiplicatifs de base utilisent des entiers.
        if F^type /= TX^tds.searchType("int", true) then
            error(MCS_BAD_TYPE_5, "int", F^type.name());
        else
            TX^type := F^type;
        end
    end
end
}

-- Generation du code pour les operations multiplicatives (suite).
#code {
local
    h : HelperIntInterface;
do
    h := TX^gen.getIntHelper();
    -- L'operation multiplicative a lieu ici.
    -- OPMUL^code contient l'appel a l'operateur.
    if OPMUL^toBool then
        -- Si l'operateur utilise necessite une conversion prealable en booleen.
        TX^code := h.generateIntToBool() + F^rightCode + h.generateIntToBool() + OPMUL^code + TX1^code;
    else
        TX^code := F^rightCode + OPMUL^code + TX1^code;
    end
end
}

--
--
-- Fin de la multiplication.
TX -> #type #code;

-- Verification du type d'une operation multiplicative (fin).
#type {
local
do
    TX^type := null;
end
}

-- Pas de code genere.
#code {
do
	TX^code := "";
end
}

--
--
-- Operateurs multiplicatifs.

OPMUL -> mult #code ;

-- Generation de code : appel de la subroutine correspondante.
#code {
local
    h : HelperIntInterface;
do
    h := OPMUL^gen.getIntHelper();
    OPMUL^code := h.generateMul();
    OPMUL^toBool := false;
end
}

OPMUL -> div #code ;

-- Generation de code : appel de la subroutine correspondante.
#code {
local
    h : HelperIntInterface;
do
    h := OPMUL^gen.getIntHelper();
    OPMUL^code := h.generateDiv();
    OPMUL^toBool := false;
end
}

OPMUL -> mod #code ;

-- Generation de code : appel de la subroutine correspondante.
#code {
local
    h : HelperIntInterface;
do
    h := OPMUL^gen.getIntHelper();
    OPMUL^code := h.generateMod();
    OPMUL^toBool := false;
end
}

OPMUL -> et #code ;

-- Generation de code : appel de la subroutine correspondante.
#code {
local
    h : HelperBoolInterface;
do
    h := OPMUL^gen.getBoolHelper();
    OPMUL^code := h.generateAnd();
    OPMUL^toBool := true;
end
}

--
--
-- -- Expressions de base
--
--

--
--
-- Constante entiere
F -> entier #type #code;

-- Une constante entiere a un type entier.
#type {
local
do
    F^type := F^tds.searchType("int", true);
end
}

-- Generation de code pour une constante entiere.
#code {
local
    h : HelperGeneralInterface;
do
    h := F^gen.getGeneralHelper();
    -- Une constante est necessairement une rightValue.
    -- TODO: Declencher une erreur de compilation si la constante est utilisee en tant que leftValue.
	F^leftCode := "";
    F^rightCode := h.generateConstante(entier^txt);
end
}

--
--
-- Constante chaine
F -> chaine #type #code ;

-- Une const-chaîne a un type de pointeur-sur-char.
#type {
local
do
    F^type := F^tds.searchType("char*", true);
end
}

#code {
local
do
	-- TODO: Generation de code.
	F^code := "";
end
}

--
--
-- Constante caractere
F -> caractere #type #code;

-- Type char.
#type {
local
do
    F^type := F^tds.searchType("char", true);
end
}

#code {
local
do
	-- TODO: Generation de code.
	F^leftCode := "";
	F^rightCode := "";
end
}


--
--
-- Expression unaire
F -> OPUN F #type #code ;

-- Propagation du type.
#type {
local
do
    F^type := F1^type;
end
}

#code {
local
do
	-- TODO: Generation de code.
    F^leftCode := "";
    F^rightCode := "";
end
}

--
--
-- Operateurs unaires
OPUN -> plus ;
OPUN -> moins ;
OPUN -> non;

--
--
-- Pointeur NULL
F -> null #type #code;

-- Type du pointeur null.
#type {
local
do
    -- TODO: Verifier le bon fonctionnement :
    -- Type null compatible avec les autres dans la verification de type ?
    F^type := null;
end
}

#code {
local
do
	-- TODO: Generation de code.
	F^leftCode := "";
	F^rightCode := "";
end
}

--
--
-- Expression parenthesee
F -> paro E parf #type1 FX #type2 #code;

-- Recuperation du type evalue.
#type1 {
local
do
    FX^typeLeft := E^type;
end
}

-- Propagation du type.
#type2 {
local
do
    F^type := FX^type;
end
}

#code {
local
do
	-- TODO: Generation de code.
	F^leftCode := "";
	F^rightCode := "";
end
}

--
--
-- Cast explicite.
F -> paro TYPE parf F #type #code ;

-- Cast explicite : on n'utilise pas le type de F.
#type {
local
do
    warning(MCS_WAR_CAST, F1^type.name(), TYPE^type.name());
    F^type := TYPE^type;
end
}

#code {
local
do
	-- TODO: Generation de code.
	F^leftCode := "";
	F^rightCode := "";
end
}

--
--
-- Typage d'un dereferencement avec *.
F -> mult F #type #code;

-- Typage d'une expression contenant *.
#type {
local
    p : PTR;
do
    if !(F1^type.isPointer()) then
        error(MCS_NOT_PTR, F1^type.name());
    else
        p := F1^type.toPointer();
        F^type := p.ptype();
    end
end
}

#code {
local
do
	-- TODO: Generation de code.
	F^leftCode := "";
	F^rightCode := "";
end
}

--
--
-- Utilisation d'un ident.
F -> ident #type1 FX #type2 #code;

-- Typage  et verification de l'existence de la variable.
#type1 {
local
    v : VAR;
do
    v := F^tds.searchVar(ident^txt, true);
    if v = null then
        error(MCS_VUN, ident^txt);
    else
        FX^typeLeft := v.type();
    end
end
}
-- Recuperation du type evalue.
#type2 {
local
do
    F^type := FX^type;
end
}

#code {
local
do
	-- TODO: Generation de code.
	F^leftCode := "";
	F^rightCode := "";
end
}

--
--
-- Fin d'evaluation du type d'un facteur.
FX -> #type #code;

-- Propagation du type racine.
#type {
local
    ft : FTYPE;
do
    -- En cas d'appel de fonction, le type resultant est le type de retour de la fonction
    -- et non le type de la fonction lui-meme.
    if (FX^typeLeft.isFType()) then
        ft := FX^typeLeft.toFType();
        FX^type := ft.retType();
    else
        -- Propagation du type.
        FX^type := FX^typeLeft;
    end
end
}

#code {
local
do
	-- TODO: Generation de code.
	FX^code := "";
end
}

--
--
-- Acces champ
FX -> pt ident #type1 FX #type2 #code;

-- Verification du type racine.
#type1 {
local
    p : STRUCT;
    c : VAR;
do
    if !(FX^typeLeft.isStruct()) then
        error(MCS_NOT_STRUCT, FX^typeLeft.name());
    else
        p := FX^typeLeft.toStruct();
        c := p.searchVar(ident^txt);
        if c = null then
            error(MCS_UNKNOWN_FIELD, ident^txt);
        else
            FX1^typeLeft := c.type();
        end
    end
end
}

-- Recuperation du type
#type2 {
local
do
    FX^type := FX1^type;
end
}

#code {
local
do
	-- TODO: Generation de code.
	FX^code := "";
end
}

--
--
-- Acces champ pointeur.
FX -> arrow  ident #type1 FX #type2 #code ;

-- Verification du type racine.
#type1 {
local
    p : PTR;
    pt : TYPE;
    s : STRUCT;
    c : VAR;
do
    if !(FX^typeLeft.isPointer()) then
        error(MCS_NOT_PTR, FX^typeLeft.name());
    else
        p := FX^typeLeft.toPointer();
        pt := p.ptype();
        if !(pt.isStruct()) then
            error(MCS_NOT_STRUCT, pt.name());
        else
            s := pt.toStruct();
            c := s.searchVar(ident^txt);
            if c = null then
                error(MCS_UNKNOWN_FIELD);
            else
                FX1^typeLeft := c.type();
            end
        end
    end
end
}

-- Recuperation du type
#type2 {
local
do
    FX^type := FX1^type;
end
}

#code {
local
do
	-- TODO: Generation de code.
	FX^code := "";
end
}

--
--
-- Appel de sous-programme
FX -> #type1 paro ES parf FX #type2 #code ;

-- Verification du type racine.
#type1 {
do
    if !(FX^typeLeft.isFType()) then
        error(MCS_NOT_FUNCTION, FX^typeLeft.name());
    else
        ES^typeF := FX^typeLeft.toFType();
        FX1^typeLeft := FX^typeLeft;
    end
end
}

-- Recuperation du type.
#type2 {
do
    FX^type := FX1^type;
end
}

#code {
local
    h : HelperFunctionInterface;
do
    h := FX^gen.getFunctionHelper();
    -- codeList contient le code pour pousser les parametres de la fonction sur la pile.
    FX^code := h.generateCall(FX^typeLeft.name(), FX^typeLeft.name(), ES^codeList) + FX1^code;
end
}

--
--
-- Appel de sous-programme sans arguments, aucune verification necessaire.
ES -> #code;

#code {
local
do
	ES^codeList := new ArrayList<String>();
end
}

--
--
-- Appel de sous-programme avec arguments.
ES -> E #type ESX #code;

-- Verification du type du parametre.
#type {
local
    tParam : TYPE;
do
    tParam := ES^typeF.getParam(0);
    if E^type /= tParam then
        error(MCS_BAD_ARGUMENT, tParam.name(), E^type.name());
    else
        ESX^numParam := 1;
    end
end
}

#code {
local
	codeListTemp : ArrayList<String>;
do
	--concatenation du code des parametres
	codeListTemp := ESX^codeList;
	codeListTemp.add(0,E^code);
	ES^codeList :=  codeListTemp;--ajout en tete de la liste du code du parametre
end
}
--
--
-- Appel de sous-programme avec arguments : fin de liste.
ESX -> #code;

#code {
local
do
	ESX^codeList := new ArrayList<String>();
end
}
--
--
-- Appel de sous-programme avec arguments : suite.
ESX -> virg E #type ESX #code;

-- Verification du type du parametre.
#type {
local
    tParam : TYPE;
do
    tParam := ESX^typeF.getParam(ESX^numParam);
    if E^type /= tParam then
        error(MCS_BAD_ARGUMENT, tParam.name(), E^type.name());
    else
        ESX1^numParam := ESX^numParam + 1;
    end
end
}

#code {
local
	codeListTemp : ArrayList<String>;
do
	--concatenation du code des parametres
	codeListTemp := ESX1^codeList;
	codeListTemp.add(0,E^code);
	ESX^codeList :=  codeListTemp;--ajout en tete de la liste du code du parametre
end
}

--
--
-- -- Inline asm
--
--

--
--
-- On peut avoir en entite de l'assembleur.
ENTITE -> asm #tds ASM #gen;

-- Utilisation de la tds au sein de l'asm.
#tds {
do
    -- TODO : Remplacer 'null' par la table courante pour que
    -- le code  ASM puisse acceder aux variables de MC ou MCS
    ASM^tds_asm := null;
end
}

-- Recuperation de l'assembleur.
#gen {
do
    -- On recupere le code assembleur 'inline' dans : ASM^code_asm ;
    ENTITE^code := ASM^code_asm ;
end
}

--
--
-- On peut avoir en instruction de l'assembleur.
INST -> asm #tds ASM #gen #type ;

-- Utilisation de la tds au sein de l'asm.
#tds {
do
    -- A remplacer par la table courante pour que
    -- l'assembleur puisse acceder aux variables
    -- TODO: gerer l'assembleur inline.
    ASM^tds_asm := null;
end
}

-- Utilisation de la tds au sein de l'asm.
#gen {
do
    -- ASM^code_asm contient le code assembleur inline
    -- dans lequel les noms de variables ont ete remplaces
    -- par leurs adresses.
    INST^code := ASM^code_asm;
end
}

-- Evaluation du type de l'instruction
#type {
do
    -- TODO: Verifier la validite de null pour une instruction ASM.
    INST^type := null;
end
}

----------------- CS extension --------------------
-- Decommenter les regles suivantes pour l'extension CS
-------------------------------------------------
--TYPE -> bool;
---- definit un contenu d'un namespace
--ENTITE -> namespace identc aco ENTITES acf ;
---- donne l acces au contenu du 'namespace'
--ENTITE -> using identc IDC pv ;
--IDC -> ;
--IDC -> pt identc IDC ;
---- definition d'une classe (peut etre en dehors d'un namespace)
--ENTITE -> ACCES class identc HERITAGE aco DEFS acf ;
---- acces
--ACCES -> public;
--ACCES -> private;
--ACCES -> ;
---- heritage
--HERITAGE -> ;
--HERITAGE -> dpts identc IDC ;
---- membres d'une classe
--DEFS -> ;
--DEFS -> ACCES DEF DEFS ;
--DEF  -> TYPE ident DECL ;
---- constructeur
--DEF  -> identc paro PARFS parf BASE BLOC;
---- appel eventuel au constructeur de la classe parente.
--BASE -> ;
--BASE -> dpts base paro ES parf  ;
---- Mode de passage pour les fonctions et methodes : rien : D, ref : D/R, out : R
--PARF -> MODE TYPE ident ;
--MODE -> ref ;
--MODE -> out ;
--F -> true;
--F -> false;
--F -> this FX;
--F -> base FX;
--F -> null2;
--F -> new identc IDC paro ES parf ;
end
