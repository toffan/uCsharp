-----------------------------------------------------
-- Grammaires de MC  et MCS                        --
-----------------------------------------------------

--
-- Options
option auto = true;
option version = 0.0.1;
option k=2;

--
-- Attributes

-- Le fichier source
inh source : MCSSourceFile for PROGRAMME;

-- La machine cible pour la generation de code.
inh machine : IMachine for
        ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
        PARFS, PARF, PARFSX, ES, ESX,
        E, AFFX, A, AX, R, RX, T, TX, F, FX
--      -- Decommenter la ligne suivante pour MCS
--      , BASE, DEFS, DEF
--      -- Fin extension MCS
        ;

-- Ces attributs permettent de recuperer les instructions du code ASM inline.
syn code_asm : STRING for ASM;

-- La TDS courante.
inh tds_asm : TDS for ASM;

-- Custom attributes.
inh tds : TDS for
        PROGRAMME, ENTITES, ENTITE, DECL,
        PARF, PARFS, PARFSX, BLOC,
        INSTS, INST, STYPE, PTRS,
        CHAMPS, CHAMP,
        A, AFFX, R, AX, T, TX, F, FX;

syn type : TYPE for
        TYPE, FONCTION, PARF, PARFS, PARFSX, DECL,
        BLOC, INSTS, INST, E, STYPE, PTRS, CHAMPS,
		A, AFFX, R, AX, T, TX, F, FX;

inh typePT : TYPE for PTRS;

inh typeCHP : TYPE for CHAMPS, CHAMP;

inh typeR : TYPE for FX;

-- Terminaux
space separateur is    "[\r\n\t ]+";
space comm is    "\/\/[^\n]*\n";
sugar paro is    "\(";
sugar parf is    "\)";
sugar aco is    "\{";
sugar acf is    "\}";
sugar virg is    ",";
sugar pt is "\.";
sugar pv is    "\;";
sugar affect is    "=";
sugar si is    "if";
sugar sinon is    "else";
sugar void is    "void";
sugar asm is    "asm";
sugar int is    "int";
sugar char is    "char";
sugar struct is "struct";
sugar typedef is "typedef";

-- Decommenter pour MCS
--sugar ref is "ref" ;
--sugar out is "out";
--sugar namespace is "namespace";
--sugar using is "using";
--sugar class is "class";
--sugar public is "public" ;
--sugar private is "private";
--sugar dpts is "\:";
--sugar bool is "bool";
--sugar true is "true";
--sugar false is "false";
--sugar this is "this";
--sugar new is "new" ;
--sugar null2 is "null";
--sugar base is "base" ;

sugar retour is    "return";
sugar arrow is "\-\>";
sugar null is    "NULL";
sugar inf is    "\<";
sugar infeg is    "\<=";
sugar sup is    "\>";
sugar supeg is    "\>=";
sugar eg is    "==";
sugar neg is    "\!=";
sugar plus is    "\+";
sugar moins is    "\-";
sugar ou is    "\|\|";
sugar mult is    "\*";
sugar div is    "\/";
sugar mod is    "\%" ;
sugar et is    "\&\&";
sugar non is    "\!";
term entier is    "[0-9]+";
term caractere is    "\'[^\']\'";
term chaine is    "\"[^\"]*\"";
term ident is    "[a-z][_0-9A-Za-z]*";
term identc is    "[A-Z][_0-9A-Za-z]*";

-- Pour les instructions en assembleur TAM 'inline'.
compil ASM;

--
--
-- Regle de production, point d'entree.
PROGRAMME -> #init ENTITES #gen;
global
    machine : IMachine;
-- Transmission de la machine cible (choisie par l'option -m au lancement)
#init {
local
do
    machine := PROGRAMME^source.getMachine();
    if machine = null then
        error(NO_MACH, PROGRAMME^source.getMachName());
    else
        ENTITES^machine := machine;
    end

    PROGRAMME^tds := new TDS();
    -- TODO: Ajouter a la TDS les types natifs, et les const char.
end
}

-- Ecrit le code dans un fichier.
#gen {
local
do
    machine.writeCode(PROGRAMME^source.getFileName(), "; no code\n");
end
}

--
--
-- -- Entites
--
--

ENTITES -> ;
ENTITES -> ENTITE ENTITES ;

--
--
-- Definition d'un nom de type (commence par une majuscule).
ENTITE -> typedef TYPE identc pv #record ;

-- Enregistrement du nouveau type dans la table des symboles.
#record {
local
        t : TYPE ;
do
    -- Verifier qu'aucun type du meme nom n'est pas deja defini localement.
    t := ENTITE^tds.searchType(identc^txt, false);
    if t /= null then
        error(MCS_TAE, identc^txt);
    else
        -- Enregistrement effectif du type.
        ENTITE^tds.putType(identc^txt, TYPE^type);
    end
end
}

--
--
-- Definition d'une variable globale ou d'une fonction.
-- (Commence par une minuscule)
ENTITE -> TYPE ident DECL #record ;

-- Enregistrement de la declaration dans la table des symboles.
#record {
local
        v : VAR ;
        t : TYPE ;
do
    -- Verifier qu'aucune fonction/variable du meme nom n'est pas deja definie
    -- localement.
    v := ENTITE^tds.searchVar(ident^txt, false);
    if v /= null then
        error(MCS_DAE, ident^txt);
    else
        -- Calcul du type de la variable/fonction.
        if DECL^type = null then
            t := TYPE^type;
        else
            -- TODO calcul du type d'une fonction.
            t := null ; -- ...
        end
        -- Enregistrement effectif de la declaration.
        ENTITE^tds.putVar(ident^txt, t);
    end
end
}

--
--
-- -- Declaration
--
--

--
--
-- Fin de la declaration, declaration vide.
DECL -> #type pv ;

-- Pas de type.
#type {
local
do
    DECL^type := null;
end
}

--
--
-- Fonction.
DECL -> #type FONCTION ;

-- Definition du champ type.
#type {
local
do
    DECL^type := FONCTION^type;
end
}

--
--
-- -- Fonction
--
--

--
--
-- Debut de la premiere ligne d'une fonction.
FONCTION -> #tds paro PARFS parf #type BLOC ;

-- Creation de la TDS interne a la fonction.
#tds {
local
    tdsFunction : TDS;
do
    tdsFunction := new TDS(FONCTION^tds);

    -- L'evaluation de PARFS va completer la TDS de la fonction.
    PARFS^tds := tdsFunction;
    BLOC^tds := tdsFunction;
end
}

-- Ajout du type de la fonction.
#type {
local
do
    FONCTION^type := PARFS^type;
end
}

--
--
-- Pas de parametre a la fonction.
PARFS -> #type ;

-- Pas de type pour pas de parametre.
#type {
local
do
    PARFSX^type := null;
end
}

--
--
-- Un parametre de plus a la fonction.
PARFS -> PARF PARFSX #type ;

-- Ajout du parametre courant au type.
#type {
local
do
    PARFSX1^type.put(PARF^type);
    PARFSX^type := PARFSX1^type;
end
}

--
--
-- Fin de la liste de parametres.
PARFSX -> #type ;

-- Pas de type.
#type {
local
do
    PARFSX^type := null;
end
}

--
--
-- Un element supplementaire a la liste des parametres (avec virgule).
PARFSX -> virg PARF PARFSX #type ;

-- Ajout du parametre courant au type.
#type {
local
do
    PARFSX1^type.put(PARF^type);
    PARFSX^type := PARFSX1^type;
end
}

--
--
-- Decomposition d'un parametre de fonction.
PARF -> TYPE ident #type #record ;

-- Definition du type du parametre de la fonction.
#type {
local
do
    PARF^type := TYPE^type;
end
}

-- Enregistrement du parametre dans la table des symboles de la fonction.
#record {
local
        v : VAR ;
do
    -- Verifier qu'aucun parametre du meme nom n'est pas deja defini localement.
    v := PARF^tds.searchVar(ident^txt, false);
    if v /= null then
        error(MCS_PAE, ident^txt);
    else
        -- Enregistrement effectif du parametre.
        PARF^tds.putVar(ident^txt, TYPE^type);
    end
end
}

--
--
-- -- Types
--
--

--
--
-- Structure d'un type, pointeur ou non.
TYPE -> STYPE #type1 PTRS #type2 ;

-- Propagation du premier type.
#type1 {
local
do
    PTRS^typePT := STYPE^type;
end
}

-- Propagation du second type.
#type2 {
local
do
    TYPE^type := PTRS^type;
end
}

--
--
-- Pointeur, fin de la liste d'etoile.
PTRS -> #type ;

-- Propagation du type du pointeur.
#type {
local
do
    PTRS^type := PTRS^typePT;
end
}

--
--
-- Pointeur, une etoile de plus dans la liste d'etoiles.
PTRS -> mult PTRS #type ;

-- Ajout du type a la table des symboles.
#type {
local
    t : PTR;
    o : PTR;
do
    -- Instanciation d'un type pointeur.
    t := new PTR(PTRS1^type);

    -- Recherche du type pointeur dans la table des types.
    o := PTRS^tds.searchType(t.name());

    -- Propagation du type.
    if o /= null then
        -- L'instance precedemment creee.
        PTRS^type := o;
    else
        -- L'instance nouvellement creee.
        PTRS^type := t;
    end
end
}

--
--
-- Types de base (void)
STYPE-> void #type ;

-- Les types de base sont deja presents dans la TDS.
#type {
local
do
    STYPE^type := STYPE^tds.searchType(void^txt, true);
end
}

--
--
-- Types de base (int)
STYPE-> int #type ;

-- Les types de base sont deja presents dans la TDS.
#type {
local
do
    STYPE^type := STYPE^tds.searchType(int^txt, true);
end
}

--
--
-- Types de base (char)
STYPE-> char #type ;

-- Les types de base sont deja presents dans la TDS.
#type {
local
do
    STYPE^type := STYPE^tds.searchType(char^txt, true);
end
}

--
--
-- Identificateur d'un type (pour les types nommes par le codeur).
STYPE -> identc #type ;

-- Resolution du type nomme dans la TDS.
#type {
local
    t : TYPE;
do
    t := STYPE^tds.searchType(identc^txt, true);
    if t = null then
        error(MCS_TUN, identc^txt);
    else
        STYPE^type := t;
    end
end
}

--
--
-- Type d'une struct.
STYPE -> #type1 struct aco CHAMPS acf #type2 ;

-- Creation du type struct initial (vide).
#type1 {
local
do
    CHAMPS^typeCHP := new STRUCT();
end
}

-- Propagation du type struct complete.
#type2 {
local
do
    STYPE^type := CHAMPS^type;
end
}

--
--
-- Fin de l'evaluation du type struct, propagation du type.
CHAMPS -> #type ;

-- Propagation du type.
#type {
local
do
    CHAMPS^type := CHAMPS^typeCHP;
end
}

--
--
-- Evaluation du type struct, liste de champ.
CHAMPS -> #type1 CHAMP CHAMPS #type2 ;

-- Enregistrement d'un champ.
#type1 {
local
do
    CHAMP^typeCHP := CHAMPS^typeCHP;
    CHAMPS1^typeCHP := CHAMPS^typeCHP;
end
}

-- Propagation du type.
#type2 {
local
do
    CHAMPS^type := CHAMPS1^type;
end
}

--
--
-- Decomposition du contenu d'un champ.
CHAMP -> TYPE ident pv #type ;

-- Enregistrement du type d'un champ dans la TPS de la struct.
#type {
local
    v : VAR ;
do
    -- Verifier qu'aucune fonction/variable du meme nom n'est pas deja definie
    -- localement dans la struct.
    v := CHAMP^typeCHP.searchVar(ident^txt, false);
    if v /= null then
        error(MCS_DAE, ident^txt);
    else
        -- Enregistrement effectif de la declaration.
        CHAMP^typeCHP.putVar(ident^txt, TYPE^type);
    end
end
}

--
--
-- -- Bloc de code
--
--

--
--
-- Delimitation d'un bloc de code.
BLOC -> aco INSTS acf #type ;

-- Le type propage est non-null si le bloc contient une instruction " return ".
#type {
local
do
    BLOC^type := INSTS^type;
end
}

--
--
-- Instruction vide, effet de bord.
INSTS -> #type ;

-- Un effet de bord ne retourne rien, type null.
#type {
local
do
    INSTS^type := null;
end
}

--
--
-- Ajout d'une instruction dans le bloc.
INSTS -> INST INSTS #type ;

-- Le type d'une instruction INST (differente d'une expression E) est soit :
--    - null (effet de bord).
--    - Resultat d'un return.
#type {
local
do
    -- Le type d'une liste d'instructions INSTS est le type de la premiere INST
    --     de type non-null (i.e. du premier return de la sequence).
    if INST^type /= null then
        INSTS^type := INST^type;
    else
        INSTS^type := INSTS1^type;
    end
end
}

--
--
-- Declaration d'une variable locale, avec ou sans initialisation.
INST -> TYPE ident AFFX pv #type ;

-- Une declaration ou une affectation est un effet de bord, pas de type.
#type {
local
do
    INST^type := null;

    -- TODO: Verification coherence de type ident/expression affecte.
    --       (dans une affectation par exemple)
end
}

--
--
-- Instruction " expression " (affectation et appel de procedure).
INST -> E pv #type ;

-- Une expression seule est un effet de bord, pas de type.
#type {
local
do
    INST^type := null;
end
}


--
--
-- Un nouveau bloc est insere en instruction.
INST -> BLOC #type ;

-- Un nouveau bloc est insere en instruction, si il est dote d'un type de
-- retour, il contient un " return ", et son type se propage
#type {
local
do
    INST^type := BLOC^type;
end
}

--
--
-- Bloc conditionnel.
INST -> si paro E parf BLOC SIX #type ;

-- Le type du bloc conditionnel correspond au type de retour commun.
#type {
local
do
    -- Une expression conditionnelle est de type de retour entier.
    if E^type /= INST^tds.searchType(int^txt) then
        -- TODO: Completer l'erreur avec du texte representant l'expression.
        error(MCS_NOT_BOOLEAN);
    else
        if BLOC^type /= null then
            if SIX^type /= null then
	            if BLOC^type /= SIX^type then
	                -- Les deux bloc renvoient des types differents, erreur.
	                error(MCS_BAD_TYPE);
	            else
	                -- Les deux blocs existent et renvoient le meme type.
	                INST^type := BLOC^type;
	            end
            else
	            -- Pas de deuxieme bloc, ou un bloc d'effets de bord.
	            INST^type := BLOC^type;
            end
        else
            -- Le premier bloc ne contient que des effets de bord.
            -- (On utilise le type de retour de SIX)
            INST^type := SIX^type;
        end
    end
end
}

--
--
-- Bloc sinon.
SIX -> sinon BLOC #type ;

-- Propagation du type.
#type {
local
do
    SIX^type := BLOC^type;
end
}

--
--
-- Pas de bloc suivant dans la conditionnelle.
SIX -> #type ;

-- Pas de bloc, considere comme un effet de bord.
#type {
local
do
    SIX^type := null;
end
}

--
--
-- L'instruction retourne un type, un " return de fonction ".
INST -> retour E pv #type ;
#type {
local
do
    -- Instruction return : on transfere le type de l'expression renvoyee.
    INST^type := E^type;
end
}

--
--
-- -- Expressions
--
--

-------------------------------------------------------------------------
-- Lexique                                                              -
-------------------------------------------------------------------------
-- E = Expression (y compris l'affectation)                             -
-- A = Expression figurant dans une affectation                         -
-- R = Expression figurant dans une expresion relationnelle             -
-- T = Expression figurant dans une expression additive (TERME)         -
-- F = Expression figurant dans une expression multiplicative (FACTEUR) -
-------------------------------------------------------------------------

--
--
-- Expression qui affecte.
E -> A AFFX #type ;

-- Verification du type des affectations.
#type {
local
do
    if AFFX^type /= null && AFFX^type /= A^type then
        error(MCS_BAD_TYPE_2);
    end
    E^type := A^type;
end
}

--
--
-- Affectation
AFFX -> affectA #type ;

-- Verification du type des affectations (suite).
#type {
local
do
    AFFX^type := A^type;
end
}

--
--
-- Fin d'une affectation.
AFFX -> #type ;

-- Verification du type des affectations (fin).
#type {
local
do
    AFFX^type := null;
end
}

--
--
-- Relation, moins prioritaire que A.
A -> R AX #type ;

-- Verification du type d'une relation.
#type {
local
do
    if AX^type /= null then
        if AX^type /= R^type then
            error(MCS_BAD_TYPE_3);
        else
            -- Condition : type int ou bool selon la version.
            A^type := A^tds.searchType(int^txt);
        end
    else
	    -- Condition : type int ou bool selon la version.
	    A^type := A^tds.searchType(int^txt, true);
    end
end
}

--
--
-- Operateur relationnel.
AX -> OPREL R #type ;

-- Verification du type d'une relation (suite).
#type {
local
do
    AX^type := R^type;
end
}

--
--
-- Fin de la relation.
AX -> #type ;

-- Verification du type d'une relation (fin).
#type {
local
do
    AX^type := null;
end
}

--
--
-- Operatieurs relationnels.
OPREL -> inf ;
OPREL -> sup ;
OPREL -> infeg ;
OPREL -> supeg ;
OPREL -> eg ;
OPREL -> neg ;

--
--
-- Terme.
R -> T RX #type ;

-- Verification du type d'une operation additive.
#type {
local
do
    if RX^type /= null && RX^type /= T^type then
        error(MCS_BAD_TYPE_4);
    else
        R^type := T^type;
    end
end
}

--
--
-- Additions ...
RX -> OPADD T RX #type ;

-- Verification du type d'une operation additive (suite).
#type {
local
do
    if RX1^type /= null && RX1^type /= T^type then
        error(MCS_BAD_TYPE_4);
    else
        RX^type := T^type;
    end
end
}

--
--
-- Fin d'une addition.
RX -> #type ;

-- Verification du type d'une operation additive (fin).
#type {
local
do
    RX^type := null;
end
}

--
--
-- Operateurs additifs.
OPADD -> plus ;
OPADD -> moins ;
OPADD -> ou ;

--
--
-- Multiplication, ...
T -> F TX #type ;

-- Verification du type d'une operation multiplicative.
#type {
local
do
    if TX^type /= null && TX^type /= F^type then
        error(MCS_BAD_TYPE_5);
    else
        T^type := F^type;
    end
end
}

--
--
-- Suite de la multiplication.
TX -> OPMUL F TX #type ;

-- Verification du type d'une operation multiplicative (suite).
#type {
local
do
    if TX1^type /= null && TX1^type /= F^type then
        error(MCS_BAD_TYPE_5);
    else
        TX^type := F^type;
    end
end
}

--
--
-- Fin de la multiplication.
TX -> #type ;

-- Verification du type d'une operation multiplicative (fin).
#type {
local
do
    TX^type := null;
end
}

--
--
-- Operateurs multiplicatifs.
OPMUL -> mult ;
OPMUL -> div ;
OPMUL -> mod ;
OPMUL -> et ;

--
--
-- -- Expressions de base
--
--

--
--
-- Constante entiere
F -> entier #type ;

-- Une constante entiere a un type entier.
#type {
local
do
    F^type := F^tds.searchType(int^txt, true);
end
}

--
--
-- Constante chaine
F -> chaine #type ;

-- Une const-chaîne a un type de pointeur-sur-char.
#type {
local
do
    -- TODO: Ne pas dupliquer le type pointeur-sur-char (char*).
    F^type := new PTR(F^tds.searchType(char^txt));
end
}

--
--
-- Constante caractere
F -> caractere #type ;

-- Type char.
#type {
local
do
    F^type := F^tds.searchType(char^txt, true);
end
}

--
--
-- Expression unaire
F -> OPUN F #type ;

-- Propagation du type.
#type {
local
do
    F^type := F1^type;
end
}

--
--
-- Operateurs unaires
OPUN -> plus ;
OPUN -> moins ;
OPUN -> non;

--
--
-- Pointeur NULL
F -> null #type ;

-- Type du pointeur null.
#type {
local
do
    -- TODO: Verifier le bon fonctionnement :
    -- -- Type null compatible avec les autres dans la verification de type ?
    F^type := null;
end
}

--
--
-- Expression parenthesee
F -> paro E parf #type1 FX #type2 ;

-- Recuperation du type evalue.
#type1 {
local
do
    FX^typeR := E^type;
end
}

-- Propagation du type.
#type2 {
local
do
    F^type := FX^type;
end
}

-- TODO: Verifier si cette regle est utilisee.
FX -> #type ;
#type {
local
do
    FX^type := FX^typeR;
end
}

--
--
-- Cast explicite.
F -> paro TYPE parf F #type ;

-- Cast explicite : on n'utilise pas le type de F.
#type {
local
do
    F^type := TYPE^type;
end
}

--
--
-- Typage de la multiplication avec *.
F -> mult F #type ;

-- Typage d'une expression contenant *.
#type {
local
    p : PTR;
do
    if !(F1^type instanceof PTR) then
        error(MCS_NOT_PTR);
    else
        p := (PTR) F1^type;
        F^type := p.ptype();
    end
end
}

--
--
-- Utilisation d'un ident.
F -> ident #type1 FX #type2 ;

-- TODO: Ajouter un commentaire.
#type1 {
local
    v : VAR;
do
    v := F^tds.searchVar(ident^txt, true);
    if v = null then
    error(MCS_VUN, ident^txt);
    else
    FX^typeR := v.getType();
    end
end
}
-- Recuperation du type evalue.
#type2 {
local
do
    F^type := FX^type;
end
}

--
--
-- TODO: Ajouter un commentaire.
FX -> #type ;

-- TODO: Ajouter un commentaire.
#type {
local
do
    FX^type := FX^typeR;
end
}

--
--
-- Acces champ
FX -> pt ident #type1 FX #type2 ;

-- Verification du type racine.
#type1 {
local
    p : STRUCT;
    c : VAR;
do
    if !(FX^typeR instanceof STRUCT) then
        error(MCS_NOT_STRUCT);
    else
        p := (STRUCT) FX^typeR;
        c := p.searchVar(ident^txt, false);
        if c = null then
            error(MCS_UNKNOWN_FIELD);
        else
            FX1^typeR := c.type();
        end
    end
end
}

-- Recuperation du type
#type2 {
local
do
    FX^type := FX1^type;
end
}

--
--
-- Acces champ pointeur.
FX -> arrow  ident FX ;

--
--
-- Appel de sous-programme
FX -> paro ES parf FX;

--
--
-- Arguments appel de sous-programme
ES -> ;

--
--
-- TODO: Ajouter un commentaire.
ES -> E ESX  ;

--
--
-- TODO: Ajouter un commentaire.
ESX -> ;

--
--
-- TODO: Ajouter un commentaire.
ESX -> virg E ESX ;

--
--
-- -- Inline asm
--
--

--
--
-- On peut avoir en entite de l'assembleur.
ENTITE -> asm #tds ASM #gen;

-- Utilisation de la tds au sein de l'asm.
#tds {
do
    -- TODO : Remplacer 'null' par la table courante pour que
    -- le code  ASM puisse acceder aux variables de MC ou MCS
    ASM^tds_asm := null;
end
}

-- Recuperation de l'assembleur.
#gen {
do
    -- On recupere le code assembleur 'inline' dans : ASM^code_asm ;
end
}

--
--
-- On peut avoir en instruction de l'assembleur.
INST -> asm #tds ASM #gen ;

-- Utilisation de la tds au sein de l'asm.
#tds {
do
    -- A remplacer par la table courante pour que
    -- l'assembleur puisse acceder aux variables
    ASM^tds_asm := null;
end
}

-- Utilisation de la tds au sein de l'asm.
#gen {
do
    -- ASM^code_asm contient le code assembleur inline
    -- dans lequel les noms de variables ont ete remplaces
    -- par leurs adresses.
end
}

----------------- CS extension --------------------
-- Decommenter les regles suivantes pour l'extension CS
-------------------------------------------------
--TYPE -> bool;
---- definit un contenu d'un namespace
--ENTITE -> namespace identc aco ENTITES acf ;
---- donne l acces au contenu du 'namespace'
--ENTITE -> using identc IDC pv ;
--IDC -> ;
--IDC -> pt identc IDC ;
---- definition d'une classe (peut etre en dehors d'un namespace)
--ENTITE -> ACCES class identc HERITAGE aco DEFS acf ;
---- acces
--ACCES -> public;
--ACCES -> private;
--ACCES -> ;
---- heritage
--HERITAGE -> ;
--HERITAGE -> dpts identc IDC ;
---- membres d'une classe
--DEFS -> ;
--DEFS -> ACCES DEF DEFS ;
--DEF  -> TYPE ident DECL ;
---- constructeur
--DEF  -> identc paro PARFS parf BASE BLOC;
---- appel eventuel au constructeur de la classe parente.
--BASE -> ;
--BASE -> dpts base paro ES parf  ;
---- Mode de passage pour les fonctions et methodes : rien : D, ref : D/R, out : R
--PARF -> MODE TYPE ident ;
--MODE -> ref ;
--MODE -> out ;
--F -> true;
--F -> false;
--F -> this FX;
--F -> base FX;
--F -> null2;
--F -> new identc IDC paro ES parf ;
end
